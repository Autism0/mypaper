\rhead{\xiaowuhao\sectionindex\quad基于历史修改模式的修改影响分析辅助方法}
\section{基于历史修改模式的影响分析辅助方法}
\par{对于一个软件系统来说，经过多年的开发历史，系统中各个软件实体之间存在非常复杂关联关系，当开发人员需要对其中一个软件实体进行修改时，必然会影响到其他软件实体，且影响范围会随着实体间的关联关系不断传播。因此，修改影响分析成为软件修改工作中的关键一步。修改影响分析的目的是评估一项修改任务可能带来的风险以及受影响的范围和程度。软件修改的主要目的包括增加新功能、修复缺陷或者适应新的用户需求。在同一项目或不同项目的演化历史中往往存在着相似的修改需求，这些相似修改的修改模式对于当前的修改任务有辅助作用。传统的静态影响分析以及动态影响分析方法难以捕获软件项目中复杂的依赖关系，引入历史修改模式信息可以对传统影响分析的结果进行优化，提升影响分析效果。已有的挖掘历史修改信息的影响分析方法没有涉及具体修改内容，本文从版本控制系统中收集优质开源项目的修改提交数据构建提交语料库，通过修改代码相似度以及修改需求的相似度检索相似的修改提交，再借助关键类判定方法将相似提交中的关键类作为当前修改类的等价类，引入关键类的修改模式对传统影响分析结果进行优化，从而获得最终的影响集。}
\subsection{基于历史修改模式的影响分析辅助方法概述}
\par{图\ref{fig:method}是基于历史修改模式的影响分析辅助方法总览，方法主要分为三个步骤：（1）构建历史提交语料库，（2）检索相似提交，（3）辅助影响分析。第一步，首先从版本控制器中收集大量不同项目下的代码修改提交数据，并将这些提交数据存储于本地仓库中，提交数据包括修改前代码片段、修改后代码片段以及修改注释信息。分别对每一条提交数据进行文本预处理，构建提交语料库，语料库中每一条语料包含相应提交中的代码修改信息和注释信息。第二步，对当前修改工作中的修改需求(文本描述)和修改前后的代码片段做相同的文本预处理；使用词嵌入方法Word2vec 训练提交语料库，得到词嵌入模型；利用词嵌入模型计算当前修改与历史提交的向量相似度，得到相似修改提交列表。第三步，使用关键类判定方法识别相似提交中的关键类，将关键类作为当前修改类的等价类；提取关键类与提交中其他类的耦合关系；使用传统影响分析方法得到当前修改的初始影响集，提取当前修改类与初始影响集中其他类的耦合关系；利用耦合关系的相似度将提交中关键类的修改模式映射回当前修改类，对初始影响集进行优化，得到最终影响集。}
\begin{figure}[!t]
\centering
\includegraphics[width=5.5in]{myfigure/method.pdf}
\caption{基于历史修改模式的影响分析辅助方法总览}
\label{fig:method}
\end{figure}

\subsection{提交语料库构建}
\par{本文中用于构建提交语料库的数据来源于版本控制系统Github、Sourceforge中的开源项目，这些开源项目经过长期维护存在大量代码修改的提交数据。我们从版本控制系统中筛选出182个开源项目，并从这些开源项目中收集了94778个提交数据用于构建提交语料库。}
\subsubsection{提交数据优化}
\par{本文用于构建提交语料库及验证的数据来源于开源项目中，而开源项目中代码提交数据质量良莠不齐，为了防止质量较差的提交数据对影响分析产生负面的优化效果，我们需要对用于构建语料库的提交数据进行筛选。我们对大量提交数据进行观察后，发现开源项目中修改提交主要存在以下问题(如图\ref{fig:badcommit}所示)：（1）修改提交中注释信息缺失或过短(小于3个单词)，这类提交缺乏对修改内容的有效描述信息，将影响后续相似提交的检索；（2）提交注释信息过长（大于200个单词），这类提交的注释信息中往往罗列了该修改工作中大部门琐碎的修改内容，难以判断其核心修改部分；（3）提交中只涉及一个类的代码修改，这类提交数据由于只包含一个类不存在可借鉴的修改模式；（4）提交中涉及超过二十个类的代码修改，这类提交数据通常是由多个普通提交组合而成，一般出现在版本更新的代码提交中。
\begin{figure}[!hbp]
\centering
\subfigure[提交注释信息过短]{
\label{Fig.sub.1}
\includegraphics[width=4in]{myfigure/shortcomment.png}}
%\includegraphics[width = 4cm ]{1.jpg}
\subfigure[提交注释信息过长]{
\label{Fig.sub.5}
\includegraphics[width=4in]{myfigure/longcomment.png}}
\subfigure[提交只涉及一个类修改]{
\label{Fig.sub.6}
\includegraphics[width=4in]{myfigure/1class.png}}
\subfigure[提交涉及超过二十个类修改]{
\label{Fig.sub.2}
\includegraphics[width=4in]{myfigure/20class.png}}
\caption{存在问题的提交图例}
\label{fig:badcommit}
\end{figure}
}
\par{通过对存在问题的提交数据筛选后，我们收集的提交数据包含182个开源项目共94778 条。一条提交数据主要包含：提交编号、作者、提交日期、提交注释文本、修改前版本代码和修改后代码版本代码等。在相似提交检索任务中，本文通过修改描述文本的相似度以及代码修改片段的相似度来衡量当前修改与提交的相似度，因此，我们收集的提交数据仅需保留提交注释文本、修改前版本代码和修改后版本代码。}
\subsubsection{文本预处理}
\par{提交中代码数据和注释文本中通常存在许多噪声字符，这些噪声可能会消弱文本中原有的语义信息。从开源项目中收集的提交数据直接用于相似提交检索有可能起负面作用，我们需要对提交中的代码及注释文本进行预处理。}
\par{第一步，对代码及注释文本使用相同预处理方法。对代码及注释文本中的标点符号、特殊字符、数字等进行过滤，并通过空格、换行符将代码及注释文本分别转化为一系列字符串和或者单词。将文本中所有的单词同一规范化为小写单词，如“\emph{Text}”转换为\emph{“text”}。 另外，开发人员喜欢在编写注释和代码时，使用缩略词，在文本预处理中，需要对缩略词进行补全，如\emph{“Info”}转换为“\emph{imformation}”。同时，词形还原和词干提取也是文本预处理中重要的一步，通过对单词规范化，可以显著提高文本相似度计算中的精确度。本文借助WordNet 对所有的文本做词形还原和词干提取，WordNet 是一个庞大的英语词汇数据库，不同词性的英语词汇被组织成同义词的网络。词形还原的目的是将不同形式和不同时态的单词还原为一般形式，如符数\emph{“classes”} 还原为\emph{“class”}，进行时的\emph{“running”} 还原为\emph{"run"} 等。词干提取的目的是提取文本中单词的词干或词根表示，如\emph{“effective”}转换为\emph{“effect”}，\emph{“happiness”}转换为\emph{“happy”}。}
\par{第二步，由于代码文本与自然语言形式的注释文本之间存在明显区别，需要对代码文本使用额外的预处理方法。语法分析从程序逻辑的角度衡量代码间的相似度，而语义分析是直接根据代码中的标识符判定代码的相似度。但是，代码文本中许多标识符并不能对语义相似度的分析起到促进作用（例如，\emph{“asaa”}，\emph{“a”}，\emph{“b”}等等）。本文通过使用一系列方法过滤代码文本中特定的标识符，包括：(1)过滤代码文本中的虚词，如\emph{“and”}，\emph{“a”}，\emph{“an”}等；（2）过滤不表示单词的字符串，如\emph{“ttt”}，\emph{“hgkk”}等等；(3)将使用驼峰命名法的词汇分割成单独的单词，如\emph{“removeContextInfo”}分割成\emph{“remove”}，\emph{“Context”}和\emph{“Info”}。经过一些列文本预处理后，提交中的原始代码片段仅保留了具有语义信息的实词，每块代码片段相当于一个文本文档。}
\par{另外，本方法除了需要对历史提交数据进行文本预处理之外，还需要对当前影响分析对象进行相同的文本预处理。当前修改需求的自然语言描述相当于提交中的注释文本，当前修改的代码变更片段相当于提交中代码修改片段。}
\subsubsection{提交语料库构建}
\par{本文提出的方法需要从本地提交库中检索与当前修改任务最相似的代码提交，其中关键点是计算当前修改代码、修改描述与提交中修改代码、提交注释之间的相似度。提交中的注释文本和代码文本经过预处理后可以融合成一条代表提交的语料信息，我们通过所有提交的语料信息构建提交语料库。其中，值得注意的是，对于代码文本（无论是提交中代码，还是当前修改任务中代码）首先需要识别其中涉及修改的代码段。另外，一个提交中通常涉及多个类的修改，需要识别其中核心修改的类，作为当前修改类的等价类。}
\par{本文使用\emph{ChangeDistiller}方法\cite{fluri2007change} 中修改前后两个版本的代码文本中提取涉及修改的代码段。\emph{ChangeDistiller}方法通过对比两个版本代码对应的抽象语法树之间的差异来获取涉及修改的代码段。由于提交中存在多种修改任务，\emph{ChangeDistiller}方法还能识别提交中不同的代码修改类型，例如：参数名变更（\emph{“Parameter Renaming”}），参数增加/删除（\emph{“Parameter Insert/Delete”}），方法名变更（\emph{“Method Renaming”}），语句增加/删除（\emph{“Statement Insert/Delete”}）等。另外，我们使用关键类判定方法识别提交中核心修改的类。关键类判定方法将在后文介绍。}
\par{对于提交中注释文本、代码修改前片段及代码修改后片段，我们分两方面处理，首先将三个文本储存于提交库中用于后续相似提交检索，此外，将提交库中所有提交的文本语料融合成语料库，用于训练词嵌入模型。本文语料库的组织形式如下：}
\par{对于注释文本中每个单词$w_{i}$，从修改前代码文本中随机选取四个标识符$Id_{a1}$、$Id_{a2}$、$Id_{a3}$、$Id_{a4}$，组合成{$Id_{a1}$、$Id_{a2}$、$w_{i}$、$Id_{a3}$、$Id_{a4}$}，记为$Com_{1}$；从修改后代码文本中随机选取四个标识符$Id_{b1}$、$Id_{b2}$、$Id_{b3}$、$Id_{b4}$,组合成{$Id_{b1}$、$Id_{b2}$、$w_{i}$、$Id_{b3}$、$Id_{b4}$},记为$Com_{2}$；从而，针对注释文本中每个单词得到组合语料$Com_{w_{i}}=\{Com_{1},Com_{2}\}$，所有$Com_{w_{i}}$组合得到注释文本对应语料$Set_{w}$。}
\par{对于修改前代码中每个标识符$Id_{ai}$，则随机从注释文本中选取四个单词$w_{1}$、$w_{2}$、$w_{3}$、$w_{4}$，与$Id_{ai}$组合成{$w_{1}$、$w_{2}$、$Id_{ai}$、$w_{3}$、$w_{4}$}，记为$Com_{Id_{a}}$，所有的$Com_{Id_{a}}$组合得到修改前代码对应语料$Set_{Id_{a}}$；类似地，对于修改后代码中每个标识符$Id_{bi}$，随机从注释文本中选取四个单词$w_{1}$、$w_{2}$、$w_{3}$、$w_{4}$，与$Id_{bi}$组合成{$w_{1}$、$w_{2}$、$Id_{bi}$、$w_{3}$、$w_{4}$}，记为$Com_{Id_{b}}$，所有的$Com_{Id_{b}}$组合得到修改前代码对应语料$Set_{Id_{b}}$。}
\par{最后，将每个提交对应的$Set_{w}$、$Set_{Id_{a}}$、$Set_{Id_{b}}$组合成一条语料，所有提交对应的语料信息组合得到完整的语料库（如图\ref{fig:corpus}所示）。
\begin{figure}[!t]
\centering
\includegraphics[width=5in]{myfigure/corpus.png}
\caption{提交语料库构建方式图示}
\label{fig:corpus}
\end{figure}}
\subsection{相似提交的检索}
\par{本节详细介绍了从本地提交库中检索相似提交的过程。我们通过提交语料库训练词向量模型，再根据词向量模型计算提交与当前修改对象之间的相似度，筛选出相似度最高的前20 个提交用于后续影响分析结果优化。提交与当前对象的相似度结合了修改代码相似度以及修改文本描述的相似度。}
\subsubsection{词向量模型训练}
\par{当前，计算文本之间语义相似度的方法主要有两种：一种是基于WordNet的语义相似度计算方法。WordNet由庞大的词汇数据库构成，通过同义词集形成词汇网络。其中，同义词通过概念-语义和词汇关系相互关联。两个单词间的语义相似度可以通过计算他们在WordNet构成的单词网络中的所在位置的距离衡量。另一种是基于词嵌入技术（Word Embedding）的语义相似度计算方法。词嵌入技术使用多层神经网络将单词投射到语义空间中，从而可以确定词与词之间的语义距离或语义相似度。其核心思想是通过嵌入一个线性的投影矩阵，将稀疏的One-hot向量（除了一个词典索引的下标对应的方向上是1，其余方向上都是0）映射为一个稠密的联系向量，并通过一个语言模型的任务去学习向量的权重。}
\par{本文正是采用基于词嵌入技术的Word2vec方法\cite{goldberg2014word2vec} 训练词向量模型。Word2vec的基本思想是通过训练将每个词映射为K维向量（K是认为设定的超参数），再根据词与词之间的向量距离来确定它们的语义相似度。其模型由三层神经网络构成，输入层-隐藏层-输出层，通过三层神经网络对语言模型进行建模，从而得到单词在向量空间上的表示。与潜在语义分析（Latent Semantic Index）、潜在狄利克雷分配（Latent Dirchlet Allocation）相比，Word2vec充分利用了上下文信息，使得语义信息更加准确。Word2vec的训练模型主要分为两种，CBOW 模型和Skip-Gram 模型（如图\ref{fig:word2vec}所示）。这两种模型主要的区别在于词向量模型训练过程中，CBOW模型根据上下文信息预测目标单词的概率分布，而Skip-Gram 模型则是通过当前单词预测其上下文的概率\cite{mikolov2013distributed,mikolov2013efficient}。
\begin{figure}[!t]
\centering
\includegraphics[width=5in]{myfigure/word2vec.png}
\caption{CBOW与Skip-Gram模型区别}
\label{fig:word2vec}
\end{figure}}
\par{本文采用的词向量模型为Skip-Gram模型，模型的训练目标是最大化以下目标函数：
\begin{equation}
\sum_{i = 1}^{n}\sum_{-k\leq j \leq k,j \neq 0}^{}\log p(w_{i+j}|w_{i})
\end{equation}
其中，$w_{i}$和$w_{i+j}$分别表示长度为$2k+1$的上下文滑动窗口中的中心词和中心词的上下文(本文中取$k=2$，即滑动窗口大小为5)，n代表语句的长度。式子$\log p(w_{i+j}|w_{i})$表示一个条件概率, 该条件概率由softmax函数定义，如下所示:
\begin{equation}
\log p(w_{i+j}|w_{i}) = \frac{\exp(v_{w_{i+j}}^{'T}v_{w_{i}})}{\sum_{w \in W}\exp(v_{w}^{'T}v_{w_{i}})}
\end{equation}
其中，$v_{w}$表示输入向量，$v_{w}^{'}$表示模型中的单词$w$的输出向量。$W$表示所有单词的词汇。而$p(w_{i+j}|w_{i})$为在中心词$w_{i}$的上下文中出现的单词$w_{i+j}$ 的归一化概率。我们采用负抽样方法来计算这个概率。}
\subsubsection{获取相似提交列表}
\par{通过以上方法得到词向量模型后，我们可以得到提交语料中每个单词的向量表示。本文根据向量的余弦距离度量两个文本之间的相似度，再筛选出相似度最高的前20 个提交构成相似提交列表。文本相似度的计算方法如下：}
\par{对于文本$C$、文本$S$中任意单词$w_{c}$和$w_{s}$，其中$w_{c}\in C$，$w_{s}\in S$，$w_{c}$和$w_{s}$相似度为：
\begin{equation}
sim(w_{c},w_{s}) = \cos (\textbf{w}_{c},\textbf{w}_{s}) = \frac {\textbf{w}_{c}^{T} \textbf{w}_{s}} {||\textbf{w}_{c}|| ||\textbf{w}_{s}||}
\end{equation}
}
\par{对于单词$w_{c}$与文本$S$的语义相似度，则取单词$w_{c}$ 与文本$S$中所有单词之间相似度的最高值，公式如下：
\begin{equation}
sim(w_{c},S) = \max_{w_{s} \in S} sim(w_{c},w_{s})
\end{equation}}
\par{由于在文本相似度计算中TF-IDF值作为单词权重的方法会造成近似相交性\cite{mikolov2013distributed}。本文采用文本$C$中单词与文本$S$相似度的平均值作为文本$C$到文本$S$的相似度。另外，我们忽略与文本相似度为0的单词，作如下集合定义：
\begin{equation}
Set(C\rightarrow S)=\left \{w_{c}\in C|sim(w_{c},S)\neq 0  \right \}
\end{equation}
}
\par{文本$C$到文本$S$的相似度为：
\begin{equation}
sim(C\rightarrow S)=\frac{ \sum_{w_{c}\in Set(C\rightarrow S)}sim(w_{c},S)}{\left | Set(C\rightarrow S) \right |}
\end{equation}
}
\par{同理，文本$S$到文本$C$的相似度为：
\begin{equation}
sim(S\rightarrow C)=\frac{ \sum_{w_{s}\in Set(S\rightarrow C)}sim(w_{s},C)}{\left | Set(S\rightarrow C) \right |}
\end{equation}
}
\par{由此，我们可以得到文本$C$与文本$S$的相似度：
\begin{equation}
sim(C,S)=\frac{sim(C\rightarrow S)+sim(S\rightarrow C)}{2}
\end{equation}
}
\par{本文中提交与影响分析对象的相似度有三部分度量：（1）提交注释文本与影响分析对象修改目标的相似度$CommentSim$；（2）提交中旧版本代码修改片段与影响分析对象修改前代码片段的相似度$OldCodeSim$；（3）提交中新版本代码修改片段与影响分析对象修改后代码片段的相似度$NewCodeSim$。三者赋予不同的权重得到提交的综合相似度$CommitSimi$，公式如下：
\begin{equation}
CommitSimi = \alpha \cdot CommentSimi + \beta \cdot OldCodeSimi+\gamma \cdot NewCodeSimi
\end{equation}
}
\par{在实验测试中得到最优权重组合为：$\alpha=0.4$、$\beta=0.3$、$\gamma=0.3$。}
\subsection{关键类判定方法}
\par{本文提出的影响分析辅助方法中一个关键步骤是从相似提交中找出影响分析对象的等价类，使用等价类的修改模式对初始影响分析结果进行优化。本文通过关键类判定方法识别提交中核心修改的类，将关键类作为影响分析对象的等价类。我们从代码耦合、代码修改以及提交类型三个维度提取特征（如表\ref{tab:coreclass}所示），训练机器学习模型，通过机器学习模型判别提交中的关键类。本节主要介绍三个维度的特征提取方法。}
\par{代码耦合特征是一次代码提交中，多个类修改之间的代码耦合关系。在代码耦合特征中，我们使用类的入度和出度来衡量一个类与其他类之间的耦合关系。一个类的入度是指提交中引用该类的其他类的个数；出度指的是提交中被该类引用的其他类的个数。同时，我们还考虑了提交中不同类之间的出度与入度的关系。假设当前类的入度为提交中所有类的入度的最大值，意味着当前类经常被其他类引用，那么这个类的修改很大概率会引起其他类的修改，更可能成为提交中的关键类。同理，如果一个类的出度很大，也就意味着这个类受其他类的修改影响比较大，这个类有比较高的概率是非关键类。一个类的入度和出度的不同组合也可能影响关键类的判别。如一个类的入度和出度都很大，说明这个类影响其他类的修改以及受其他类修改的影响都比较大。如果一个类的入度很大，而出度为0，这个类有很大概率成为关键类；相反地，如果一个类的出度很大，而入度为0，这个类更可能是非关键类。}
\par{对于一个提交，类的代码修改量往往对应着这个类在提交中的重要程度，关键类在一次提交中往往是被主要修改的类。从修改代码量维度衡量，关键类修改的代码量通常要比非关键类多。类修改的代码量可以使用类中方法的修改个数和代码的修改行数来度量。同时，我们还在代码修改特征中引入代码相对修改量的概念，即在一次提交中，类中代码修改量与提交中涉及的类的平均代码修改量的比值。另外，类的修改类型可以分为新增，修改和删除三种。我们定义的代码修改特征如表。% Please add the following required packages to your document
}
\par{在一次提交中，代码修改的目标有几种类型：（1）添加新功能（前向工程）；（2）删除过时代码（逆向工程）；（3）修复代码缺陷（纠错工程）；（4）非可执行文件修改（非代码修改类型），如配置文件，说明文件等。根据提交的类型不同，提交中被核心修改的类也会有所不同。如：提交类型为添加新功能，关键类通常为新增的类。因此，如果已知一个提交的类型，可以将当前提交的关键类限定在一个更小的范围内。}
% Please add the following required packages to your document preamble:
% \usepackage{multirow}
\begin{table}[ht]
\small
 % \fontsize{8}{8}\selectfont
\caption{关键类判别特征}
\label{tab:coreclass}
\begin{center}
\begin{footnotesize}
\setlength{\tabcolsep}{7mm}{
\begin{tabular}{|c|c|c|}
\hline
\textbf{类型}                      & \textbf{编号} & \textbf{描述}                  \\ \hline
\multirow{8}{*}{代码耦合特征} & 01 & 入度                  \\ \cline{2-3}
                        & 02 & 入度/提交中类最大入度         \\ \cline{2-3}
                        & 03 & 入度/提交中类平均入度         \\ \cline{2-3}
                        & 04 & 出度                  \\ \cline{2-3}
                        & 05 & 出度/提交中类最大出度         \\ \cline{2-3}
                        & 06 & 出度/提交中类平均出度         \\ \cline{2-3}
                        & 07 & 入度是否为零              \\ \cline{2-3}
                        & 08 & 出度是否为零              \\ \hline
\multirow{8}{*}{代码修改特征} & 09 & 代码修改行数              \\ \cline{2-3}
                        & 10 & 代码修改行数/提交中类最大代码修改行数 \\ \cline{2-3}
                        & 11 & 代码修改行数/提交中类平均代码修改行数 \\ \cline{2-3}
                        & 12 & 方法修改数               \\ \cline{2-3}
                        & 13 & 方法修改数/类中方法总数        \\ \cline{2-3}
                        & 14 & 方法修改数/提交中最大方法修改数    \\ \cline{2-3}
                        & 15 & 方法修改数/提交中平均方法修改数    \\ \cline{2-3}
                        & 16 & 修改类型                \\ \hline
\multirow{5}{*}{提交类型特征} & 17 & 是否为前向工程             \\ \cline{2-3}
                        & 18 & 是否为逆向工程             \\ \cline{2-3}
                        & 19 & 是否为纠错工程             \\ \cline{2-3}
                        & 20 & 是否非代码类型修改           \\ \cline{2-3}
                        & 21 & 提交中类的个数             \\ \hline
\end{tabular}}
\end{footnotesize}
\end{center}
\end{table}
\subsection{影响分析辅助方法}
\par{本节详细介绍基于相似提交对传统影响分析的修改影响集进行优化的过程。我们先使用传统影响分析方法得到修改类的初始影响集，初始影响集中的类称之为初始影响类。从提交库中检索得到前20 个最相似的提交，提取提交中关键类与其他类的结构耦合关系以及修改类与初始影响类的结构耦合关系，计算结构耦合关系的相似度，对相似度高于指定阈值的初始影响类，调整其在初始影响集的位置，得到最终影响集。}
\subsubsection{软件实体间结构耦合关系提取}
\par{我们提出的基于历史修改模式的影响分析辅助方法中，通过类与类之间结构耦合关系的相似性，将历史修改模式映射回当前修改类中。当相似提交中关键类A和其他类B 的结构耦合关系与当前修改类和初始影响类C 的耦合关系的相似度很高时，我们认为修改类更可能将修改影响传播给初始影响类C。我们分析的软件实体包括类、方法和属性。对于两个类A和B （或者类A，接口B），我们从类层次、方法层次以及属性层次总结了A、B 的18中耦合关系（如表\ref{coupleRelation}所示）：}
\textbf{1)} A类的类层次。主要有2种耦合类型：A类继承B类、A类实现B接口。

\textbf{2)} A类的方法层次（但没有使用B类定义局部变量或调用B 类中的静态变量、静态方法、构造方法）。主要有5种耦合类型：强制类型转换、类型检查（instanceOf）、B作为方法返回值类型、类实例、方法抛异常（B为异常类）。

\textbf{3)} A类的属性层次（成员属性、方法局部属性、方法参数），即，以B类定义A类的属性attr，attr有多种不同的使用方式，我们考虑以下三种：

\quad\quad \textbf{3.1)} 在A类中（成员属性、方法局部属性、方法参数）直接使用attr；

\quad\quad \textbf{3.2)} 在A类中（成员属性、方法局部属性、方法参数）调用attr（attr为B\\ 的实例）的某个属性；

\quad\quad \textbf{3.3)} 在A类中（成员属性、方法局部属性、方法参数）调用attr（attr为B\\ 的实例）的某个方法；

与属性层次的不同位置结合分析，可以总结出9种耦合关系。

\textbf{4)} 其他情况：在A类的方法（也可能在A类的属性、静态代码块、非静态代码块，根据调研这三种情况较少见）调用B 的静态方法或B 的构造方法，共两种耦合关系。
\par{两个类之间的18种耦合关系我们通过一个1个18维的特征向量表示，每个维度对应表\ref{coupleRelation}的编码。如果两个类之间满足某种耦合关系，该维度表示为1，否则为0。}
\begin{table}[ht]
\begin{center}
\begin{footnotesize}
\caption{类与类（接口）耦合类型表}
\label{coupleRelation}
\begin{tabular}{|c|c|c|c|} \hline
\textbf{层次} & \textbf{编码} & \multicolumn{2}{l|}{\textbf{耦合类型}} \\ \hline
\multirow{2}{*}{类层次} & 01 & \multicolumn{2}{l|}{A类继承B 类} \\ \cline{2-4}
 & 02 & \multicolumn{2}{l|}{A类实现B接口} \\ \hline
\multirow{5}{*}{方法层次} & 03 & \multicolumn{2}{l|}{强制类型转换} \\ \cline{2-4}
 & 04 & \multicolumn{2}{l|}{类型检查instanceOf} \\ \cline{2-4}
 & 05 & \multicolumn{2}{l|}{B类作为A方法返回值类型} \\ \cline{2-4}
 & 06 & \multicolumn{2}{l|}{类实例b.Class} \\ \cline{2-4}
 & 07 & \multicolumn{2}{l|}{方法抛异常（B为异常类）} \\ \hline
\multirow{9}{*}{属性层次} & 08 & \multirow{3}{*}{A成员属性attr} & 直接调用attr \\ \cline{2-2} \cline{4-4}
 & 09 &  & 通过attr调用其成员属性（attr为B类的实例） \\ \cline{2-2} \cline{4-4}
 & 10 &  & 通过attr调用其成员方法（attr为B类的实例） \\ \cline{2-4}
 & 11 & \multirow{3}{*}{A方法局部属性attr} & 直接调用attr \\ \cline{2-2} \cline{4-4}
 & 12 &  & 通过attr调用其成员属性（attr为B类的实例） \\ \cline{2-2} \cline{4-4}
 & 13 &  & 通过attr调用其成员方法（attr为B类的实例） \\ \cline{2-4}
 & 14 & \multirow{3}{*}{A方法形参attr} & 直接调用attr \\ \cline{2-2} \cline{4-4}
 & 15 &  & 通过attr调用其成员属性（attr为B类的实例） \\ \cline{2-2} \cline{4-4}
 & 16 &  & 通过attr调用其成员方法（attr为B类的实例） \\ \hline
\multirow{2}{*}{其他情况} & 17 & \multicolumn{2}{l|}{A类调用B 类的静态方法} \\ \cline{2-4}
 & 18 & \multicolumn{2}{l|}{A类调用B类的构造方法} \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\vspace{-2mm}
\end{table}
\subsubsection{初始影响集优化}
\par{通过传统影响分析方法获得初始影响集后，我们对影响集列表中的类赋予初始分数如表\ref{scoreinit}所示。影响集中类的排序代表着其受影响的概率，因此，我们记倒数第一个类为0分，逆序为排在前面的类依次增加20 分。}
\par{对于初始影响集中的每个类，首先，提取其与修改类之间的结构耦合关系，记耦合关系为$V_{i}$（18维向量）；然后，提取每个相似提交中关键类与其他类的耦合关系，记为$V_{j}$；最后，计算$V_{i}$与所有$V_{j}$相似度，若$V_{i}$与提交中有$n$个$V_{j}$ 相似度大于指定阈值$\eta$（由实验测试得出），则$V_{i}$所对应的初始影响类分数增加$n*20$分，调整其在影响集中的位置。}
\par{本文通过\emph{Jaccard}相似系数度量两组耦合关系向量之间的相似性，\emph{Jaccard}相似系数相对于其他相似性度量方法，更适合处理非对称二元变量。在两组结构耦合关系中，某一维度上的耦合关系编码正匹配（两者都取值为1）比负匹配（两者都取值为0）更有意义，在相似性度量上，负匹配的数量被认为是不重要的，\emph{Jaccard}相似系数可以忽略负匹配的影响。初始影响集优化公式如下：
\begin{equation}
JaccardSimi(V_{i},V_{j}) = \frac{V_{i}\cap V_{j}}{V_{i}\cup V_{j}}
\end{equation}
\begin{equation}
Score_{i}=
\begin{cases}
Score_{i}+20,& \text{$JaccardSimi(V_{i},V_{j})>\eta $}\\
Score_{i},& \text{$else$}
\end{cases}
\end{equation}
}
\begin{table}[t]
\begin{center}
\begin{footnotesize}
\caption{初始影响集分数赋值示例}
\label{scoreinit}
\setlength{\tabcolsep}{7mm}{
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{排序} & \textbf{类名}                            & \textbf{影响概率}      & \textbf{初始分数} \\ \hline
1  & \textit{Buffer.java}          & 0.7374193 & 240  \\ \hline
2  & \textit{EditServer.java}      & 0.6746630 & 220  \\ \hline
3  & \textit{Macros.java}          & 0.6488870 & 200  \\ \hline
4  & \textit{EditPlugin.java}      & 0.6138285 & 180  \\ \hline
5  & \textit{GUIUtilities.java}    & 0.5360856 & 160  \\ \hline
6  & \textit{BeanShell.java}       & 0.5250749 & 140  \\ \hline
7  & \textit{Abbrevs.java}         & 0.4440035 & 120  \\ \hline
8  & \textit{BufferIORequest.java} & 0.3989099 & 100  \\ \hline
9  & \textit{FileVFS.java}         & 0.3953681 & 80   \\ \hline
10 & \textit{Mode.java}            & 0.2678907 & 60   \\ \hline
11 & \textit{View.java}            & 0.1140896 & 40   \\ \hline
12 & \textit{EditPane.java}        & 0.0990951 & 20   \\ \hline
13 & \textit{HistoryModel.java}    & 0.0719621 & 0    \\ \hline
\end{tabular}}
\end{footnotesize}
\end{center}
\end{table}
\subsubsection{基于历史修改模式的影响分析算法}
\par{算法2-1是本文提出的影响分析辅助方法的算法整体流程，本节主要阐述算法的实现流程及细节。算法以当前修改目标的自然语言描述\emph{describe}，代码修改片段\emph{codefragList} 作为输入；输出目标为初始影响集优化后得到的最终影响集\emph{finImpctedSet}。}
\par{算法3-15行为相似提交的检索过程。通过2.3节中提交相似度计算方法，对比提交库中的所有提交，得到一个大小为20的相似提交列表\emph{SimiCommits}。在检索提交库过程中，若相似提交列表中提交数量低于20，则直接加入当前检索的提交；若提交列表中提交数量为20，则对比提交列表中最后一个提交（相似度最低的提交）的相似系数与当前提交的相似系数的大小，如果当前提交的相似系数更大，则更新提交列表。}
\par{算法16-30行为初始影响集\emph{initImpactedSet}的优化过程。\emph{initImpactedSet}由传统影响分析方法得到，并对影响集中的类根据受影响概率不同赋予不同的初始分数\emph{Score}。 对于\emph{initImpactedSet}中一个受影响的类\emph{impactClass}，提取其与修改类的结构耦合关系\emph{impactClassCoupleVec}；然后遍历相似提交列表\emph{SimiCommits} 中所有提交\emph{commit}，识别提交中的关键类\emph{coreclass}，对于提交中的所有非关键类\emph{otherclass}，提取其与关键类的结构耦合关系\emph{otherClassCoupleVec}，再计算\emph{impactClassCoupleVec} 与\emph{otherClassCoupleVec} 的\emph{Jaccard}相似系数，若\emph{JaccardSimi} 大于指定阈值（实验测试最优阈值为0.8），则当前受影响类\emph{impactClass} 对应的分数\emph{Score}增加20；最后对初始影响集根据分数进行重排序得到最终影响集\emph{finImpactedSet}。}
\begin{table*}[!ht]
\centering
\begin{small}
\label{algo1}
{\footnotesize%
\noindent\begin{tabular*}{135mm}{@{\extracolsep{\fill}}@{}l@{}}
\toprule
\textbf{算法2-1: 影响分析算法}\\
\midrule%
~~1:\quad \textbf{Input}: \emph{describe: 修改目标}， \emph{codefragList: 修改代码片段}; \\
~~2:\quad \textbf{Output}: \emph{finImpactedSet: 最终影响集}; \\
~~3:\quad \emph{SimiCommits} = \{\}\\
~~4:\quad \textbf{ foreach} \emph{commit} $\in$ \emph{commitCorpus} \\
~~5:\quad\quad \emph{simi} = \textbf{getTextSimi}(\emph{commit, describe, codefragList}) \\
~~6:\quad\quad \textbf{if} \emph{SimiCommits}.\textbf{size()} $<$20 \textbf{do}\\
~~7:\quad\quad\quad \emph{SimiCommits}.\textbf{add}(\emph{commit})\\
~~8:\quad\quad\textbf{end if}\\
~~9:\quad\quad \textbf{Sorted}(\emph{SimmiCommits})\\
10:\quad\quad \textbf{if} \emph{SimiCommits}.\textbf{size()} $==$ 20 \textbf{\&\&} \emph{simi} $>$ \emph{SimiCommits}.\textbf{get}(\emph{SimiCommits}.\textbf{Size}()-1).\emph{simi} \textbf{do}\\
11:\quad\quad\quad \emph{SimiCommits}.\textbf{add}(\emph{commit})\\
12:\quad\quad\quad \textbf{Sorted}(\emph{SimmiCommits})\\
13:\quad\quad\quad \emph{SimiCommits}.\textbf{remove}(\emph{SimiCommits}.\textbf{Size}()-1)\\
14:\quad\quad\textbf{end if}\\
15:\quad\textbf{end foreach}\\
16:\quad \emph{initImpactedSet} $=$ \textbf{getInitImpactedSet}(\emph{describe}, \emph{codefragList})\\
17:\quad \textbf{foreach} \emph{impactClass} $\in$ \emph{initImpactedSet} \textbf{do}\\
18:\quad\quad \emph{impactClassCoupleVec} $=$ \textbf{getCoupleVec}(\emph{changeClass,impactClass})\\
19:\quad\quad \textbf{foreach} \emph{commit} $\in$ \emph{SimiCommits} \textbf{do}\\
20:\quad\quad\quad \emph{coreclass} $=$ \textbf{getCoreClass}(\emph{commit})\\
21:\quad\quad\quad \textbf{foreach} \emph{otherclass} $\in$ \emph{commit} \textbf{do}\\
22:\quad\quad\quad\quad \emph{otherClassCoupleVec} $=$ \textbf{getCoupleVec}(\emph{coreclass, otherclass})\\
23:\quad\quad\quad\quad \emph{JaccardSimi} $=$ \textbf{getJaccard}(\emph{impactClassCoupleVec, otherClassCoupleVec})\\
24:\quad\quad\quad\quad \textbf{if} \emph{JaccardSimi} $>$ \emph{0.8} \textbf{do}\\
25:\quad\quad\quad\quad\quad \emph{impactClass}.\textbf{Score} $+=$ \emph{20}\\
26:\quad\quad\quad\quad \textbf{end if}\\
27:\quad\quad\quad \textbf{end foreach}\\
28:\quad\quad \textbf{end foreach}\\
29:\quad \textbf{end foreach}\\
30:\quad \emph{finImpactedSet} $=$ \textbf{sorted}(\emph{initImpactedSet})\\
31:\quad \textbf{return} \emph{finImpactedSet}\\
\bottomrule
\end{tabular*}
} \vspace{-3mm}
\end{small}
\end{table*}
\subsection{实验结果与分析}
\par{在本文中将介绍影响分析辅助方法的实验设计与评估。首先介绍实验数据的选取过程，然后介绍实验的评估标注，最后给出实验结果。}
\subsubsection{数据集收集}
\par{我们从开源项目中选取8个项目进行影响分析实验。这些项目均保持着长期维护，有大量优质提交信息，并且是在软件工程领域常用的开源项目。这些项目分别是FreeCol\footnote{http://www.jamwiki.org/}，HSQLDB\footnote{http://hsqldb.org/}，HtmlUnit\footnote{http://htmlunit.sourceforge.net/}，JAMWiki\footnote{http://www.jamwiki.org/}，
jEdit\footnote{http://www.jedit.org/}，jHotDraw\footnote{http://www.jhotdraw.org/}，Makagiga\footnote{https://makagiga.sourceforge.io/}，OmegaT\footnote{https://omegat.org/}。
这些开源项目代表了不同的应用领域和开发环境。
\begin{table}[ht]
\begin{center}
\begin{footnotesize}
\caption{实验项目数据信息}
\label{data1}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
\textbf{项目名} & \textbf{版本跨度} & \textbf{提交个数} & \textbf{项目名} & \textbf{版本跨度} & \textbf{提交个数} \\ \hline
FreeCol      & 0.7-1.0       & 1150          & HSQLDB       & 2.20-2.33     & 637           \\ \hline
HtmlUnit     & 2.0-2.21      & 737           & JAMWiki      & 0.82-1.3      & 499           \\ \hline
jEdit        & 4.0-4.5       & 1601          & JHotDraw     & 7.1-7.5       & 378           \\ \hline
Makagiga     & 3.82-4.12     & 2072          & OmegaT       & 2.3-3.54      & 627           \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}}
\par{同时，为了保证实验的可靠性，需要使用本文2.2.1节中提出的提交数据优化方法对实验数据集进行优化，去除只涉及一个修改类的提交（该类提交不包含影响集）以及涉及20个修改类的提交（该类提交通常由多个普通提交组合而成）。项目的详细信息如表\ref{data1}所示。}
\subsubsection{实验评估准则}
\par{影响分析研究中广泛使用召回率和精确率作为结果的度量指标，这两个指标能评估实验产生的预估影响集与真实修改产生的实际影响集之间的差异。给定软件实体$e_{s}$（本文影响分析实体为类），用$E_{imp}$表示影响分析结果中软件实体的集合（预估影响集），用$R_{imp}$ 表示实际修改中被影响的软件实体的集合（实际影响集）。则实验结果的召回率由公式\ref{recall}定义，精确率由公式\ref{precision}定义。此外，为了更细致的评估实验结果，我们对预估影响集按不同截断点进行划分，分别评估实验影响集前5、前10、前20、前50的召回率和精确率，如公式\ref{recall_cut}和公式\ref{precision_cut}定义。
\begin{equation}\label{recall}
  Recall=\frac{1}{n}\sum_{i=1}^{n}\frac{\left | E_{imp} \bigcap R_{imp}\right |}{\left | R_{imp} \right |}\times100\%
\end{equation}
\begin{equation}\label{precision}
  Precision=\frac{1}{n}\sum_{i=1}^{n}\frac{\left | E_{imp} \bigcap R_{imp}\right |}{\left | E_{imp} \right |}\times100\%
\end{equation}
\begin{equation}\label{recall_cut}
Recall(cutpoint)=\frac{1}{n}\sum_{i=1}^{n}\frac{\left | E_{imp} (cutpoint)\bigcap R_{imp}\right |}{ \left |R_{imp}\right |}\times100\%
\end{equation}
\begin{equation}\label{precision_cut}
  Precision(cutpoint)=\frac{1}{n}\sum_{i=1}^{n}\frac{\left | E_{imp} (cutpoint)\bigcap R_{imp}\right |}{ cutpoint }\times100\%
\end{equation}
}
\par{为了验证本文提出的影响分析辅助方法的有效性，我们选取两个影响分析工具$JRipples$和$Impact Miner$作为传统影响分析方法，用于产生初始影响集。$JRipples$ 工具是Eclipse官方插件，该插件是Java代码影响分析领域中被广泛使用的工具，也是实际开发中开发人员常用的影响分析工具。而$Impact Miner$则是可用工具中影响分析效果较好的一款工具，另外，$Impact Miner$工具结合了多种影响分析中的研究方法，包括：信息检索，软件历史库挖掘以及动态影响分析。}
\par{本文实验中的验证数据为开源项目中提交数据，无法直观判断其修改集和影响集。因此，我们通过关键类判定方法识别提交中的关键类，将关键类作为实验的修改集，提交中所有非关键类作为影响集。}
\par{在实验中，我们主要关注两个方面的问题：第一，我们关注的是本文提出的影响分析辅助方法，是否能提高传统影响分析工具的召回率和准确率？第二，在历史修改模式映射中，结构耦合关系的相似程度是否影响召回率和准确率？}
\subsubsection{实验结果分析}
\par{\textbf{研究问题1:我们的方法是否能提高传统影响分析的效果？}}
\par{我们分别基于$JRipples$工具和$Impact Miner$工具在8个项目上评估了影响分析辅助方法效果，实验结果如表\ref{jrriples}和表\ref{ImpactMiner}所示。实验结果显示，我们的方法在8 个项目上对两个工具的初始影响集都起到了辅助效果，证实了本文提交出方法都有效性。观察可以发现，我们的方法对$Impact Miner$的辅助效果更好，这是由于我们在实验中设置初始影响集的大小为50，而$Impact Miner$的初始影响集中包含更多实际影响类，调整空间更大。从表\ref{jrriples}中可以发现，在JAMWiki和OmegaT两个项目的实验结果中前30和前50 的召回率和精确率是相同的，这是由于我们$JRipples$在这两个项目上影响分析产生的初始影响集大小小于30，导致我们取前30和前50去评估实验结果是相同的。同时，我们可以发现，当传统影响分析方法前50召回率或精确率更高时，我们的方法的辅助效果更加明显。这是因为初始影响集中包含更多的实际影响类，在影响集重排序时，我们的方法有更大几率将实际影响类的排序位置往前移动。
\begin{table}[ht]
\begin{center}
\begin{scriptsize}
\caption{基于$JRipples$的影响分析辅助结果}
\label{jrriples}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{\textbf{项目名}} & \multirow{2}{*}{\textbf{方法}} & \multicolumn{5}{c|}{\textbf{召回率（\%）}}                                              & \multicolumn{5}{c|}{\textbf{精确率（\%）}}                                             \\ \cline{3-12}
                             &                              & \textbf{5}     & \textbf{10}    & \textbf{20}    & \textbf{30}    & \textbf{50}    & \textbf{5}     & \textbf{10}    & \textbf{20}    & \textbf{30}    & \textbf{50}   \\ \hline
\multirow{2}{*}{FreeCol}     & JRipples                     & 13.68          & 20.52          & 25.50          & 28.15          & 28.72          & 12.65          & 9.53           & 6.01           & 4.37           & 2.68          \\ \cline{2-12}
                             & \textbf{Our method}          & \textbf{14.65} & \textbf{20.42} & \textbf{25.49} & \textbf{28.19} & \textbf{28.72} & \textbf{13.65} & \textbf{9.70}  & \textbf{6.01}  & \textbf{4.38}  & \textbf{2.68} \\ \hline
\multirow{2}{*}{HSQLDB}      & JRipples                     & 16.43          & 24.76          & 42.03          & 55.67          & 61.05          & 22.56          & 18.33          & 15.13          & 13.04          & 8.93          \\ \cline{2-12}
                             & \textbf{Our method}          & \textbf{18.10} & \textbf{30.53} & \textbf{47.12} & \textbf{55.67} & \textbf{61.05} & \textbf{24.56} & \textbf{21.14} & \textbf{16.18} & \textbf{13.04} & \textbf{8.93} \\ \hline
\multirow{2}{*}{HtmlUnit}    & JRipples                     & 15.17          & 18.93          & 25.19          & 26.76          & 28.63          & 11.55          & 7.25           & 4.79           & 3.48           & 2.28          \\ \cline{2-12}
                             & \textbf{Our method}          & \textbf{17.00} & \textbf{19.89} & \textbf{25.91} & \textbf{27.30} & \textbf{28.63} & \textbf{13.14} & \textbf{8.74}  & \textbf{4.82}  & \textbf{3.52}  & \textbf{2.28} \\ \hline
\multirow{2}{*}{JAMWiki}     & JRipples                     & 24.08          & 34.12          & 38.60          & 40.07          & 40.16          & 16.30          & 12.35          & 7.35           & 5.15           & 3.11          \\ \cline{2-12}
                             & \textbf{Our method}          & \textbf{32.27} & \textbf{36.36} & \textbf{38.80} & \textbf{40.07} & \textbf{40.16} & \textbf{23.19} & \textbf{13.69} & \textbf{7.44}  & \textbf{5.15}  & \textbf{3.11} \\ \hline
\multirow{2}{*}{jEdit}       & JRipples                     & 23.59          & 34.18          & 43.77          & 47.28          & 50.10          & 16.15          & 11.15          & 6.90           & 5.19           & 3.31          \\ \cline{2-12}
                             & \textbf{Our method}          & \textbf{29.41} & \textbf{37.23} & \textbf{44.83} & \textbf{48.34} & \textbf{50.10} & \textbf{18.07} & \textbf{12.12} & \textbf{7.02}  & \textbf{5.32}  & \textbf{3.31} \\ \hline
\multirow{2}{*}{JHotDraw}    & JRipples                     & 12.82          & 16.86          & 17.29          & 18.34          & 18.82          & 11.07          & 8.39           & 4.38           & 3.21           & 2.04          \\ \cline{2-12}
                             & \textbf{Our method}          & \textbf{15.10} & \textbf{18.45} & \textbf{17.39} & \textbf{18.34} & \textbf{18.82} & \textbf{13.77} & \textbf{9.26}  & \textbf{4.44}  & \textbf{3.21}  & \textbf{2.04} \\ \hline
\multirow{2}{*}{Makagiga}    & JRipples                     & 21.78          & 30.67          & 39.54          & 46.34          & 51.74          & 24.04          & 17.41          & 12.13          & 9.78           & 6.99          \\ \cline{2-12}
                             & \textbf{Our method}          & \textbf{23.22} & \textbf{31.32} & \textbf{40.09} & \textbf{49.83} & \textbf{51.48} & \textbf{25.74} & \textbf{17.93} & \textbf{12.30} & \textbf{9.91}  & \textbf{6.99} \\ \hline
\multirow{2}{*}{OmegaT}      & JRipples                     & 39.78          & 43.93          & 44.54          & 44.54          & 44.54          & 22.04          & 12.04          & 6.02           & 6.02           & 6.02          \\ \cline{2-12}
                             & \textbf{Our method}          & \textbf{41.41} & \textbf{44.03} & \textbf{44.54} & \textbf{44.54} & \textbf{44.54} & \textbf{23.65} & \textbf{13.04} & \textbf{6.02}  & \textbf{6.02}  & \textbf{6.02} \\ \hline
\end{tabular}
\end{scriptsize}

\end{center}
\end{table}
% Please add the following required packages to your document preamble:
% \usepackage{multirow}
\begin{table}[!ht]
\begin{center}
\begin{scriptsize}
\caption{基于$Impact Miner$的影响分析辅助结果}
\label{ImpactMiner}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{\textbf{项目名}} & \multirow{2}{*}{\textbf{方法}} & \multicolumn{5}{c|}{\textbf{召回率（\%）}}                                              & \multicolumn{5}{c|}{\textbf{精确率（\%）}}                                              \\ \cline{3-12}
                              &                              & \textbf{5}     & \textbf{10}    & \textbf{20}    & \textbf{30}    & \textbf{50}    & \textbf{5}     & \textbf{10}    & \textbf{20}    & \textbf{30}    & \textbf{50}    \\ \hline
\multirow{2}{*}{FreeCol}      & Impact Miner                 & 18.22          & 24.78          & 31.23          & 34.78          & 38.39          & 18.15          & 14.63          & 12.92          & 9.63           & 5.31           \\ \cline{2-12}
                              & \textbf{Our method}          & \textbf{22.47} & \textbf{28.68} & \textbf{33.21} & \textbf{35.98} & \textbf{38.39} & \textbf{22.12} & \textbf{17.35} & \textbf{14.21} & \textbf{10.39} & \textbf{5.31}  \\ \hline
\multirow{2}{*}{HSQLDB}       & Impact Miner                 & 34.33          & 39.03          & 47.99          & 58.33          & 63.87          & 30.13          & 24.11          & 21.69          & 17.56          & 14.02          \\ \cline{2-12}
                              & \textbf{Our method}          & \textbf{41.09} & \textbf{45.42} & \textbf{51.08} & \textbf{60.77} & \textbf{63.87} & \textbf{33.77} & \textbf{27.65} & \textbf{23.00} & \textbf{18.14} & \textbf{14.02} \\ \hline
\multirow{2}{*}{HtmlUnit}     & Impact Miner                 & 18.33          & 22.43          & 28.06          & 29.97          & 31.70          & 15.48          & 11.98          & 9.97           & 7.53           & 5.89           \\ \cline{2-12}
                              & \textbf{Our method}          & \textbf{20.17} & \textbf{24.08} & \textbf{29.61} & \textbf{31.15} & \textbf{31.70} & \textbf{17.44} & \textbf{13.70} & \textbf{11.31} & \textbf{9.65}  & \textbf{5.89}  \\ \hline
\multirow{2}{*}{JAMWiki}      & Impact Miner                 & 33.80          & 38.21          & 41.26          & 45.04          & 49.19          & 19.09          & 16.38          & 12.82          & 9.95           & 7.38           \\ \cline{2-12}
                              & \textbf{Our method}          & \textbf{39.10} & \textbf{42.44} & \textbf{45.34} & \textbf{47.39} & \textbf{49.16} & \textbf{23.41} & \textbf{18.64} & \textbf{14.63} & \textbf{11.85} & \textbf{7.38}  \\ \hline
\multirow{2}{*}{jEdit}        & Impact Miner                 & 34.39          & 47.13          & 54.22          & 57.33          & 62.12          & 15.13          & 21.32          & 18.54          & 15.23          & 11.33          \\ \cline{2-12}
                              & \textbf{Our method}          & \textbf{41.44} & \textbf{53.33} & \textbf{58.83} & \textbf{60.34} & \textbf{62.12} & \textbf{30.11} & \textbf{28.49} & \textbf{23.12} & \textbf{19.83} & \textbf{11.33} \\ \hline
\multirow{2}{*}{JHotDraw}     & Impact Miner                 & 16.72          & 21.02          & 24.26          & 27.11          & 29.30          & 13.07          & 11.55          & 9.87           & 8.05           & 5.15           \\ \cline{2-12}
                              & \textbf{Our method}          & \textbf{18.25} & \textbf{24.54} & \textbf{27.24} & \textbf{28.12} & \textbf{29.30} & \textbf{14.25} & \textbf{12.54} & \textbf{11.06} & \textbf{8.49}  & \textbf{5.15}  \\ \hline
\multirow{2}{*}{Makagiga}     & Impact Miner                 & 28.31          & 35.76          & 40.01          & 48.21          & 53.87          & 29.33          & 23.54          & 17.65          & 13.33          & 10.94          \\ \cline{2-12}
                              & \textbf{Our method}          & \textbf{33.64} & \textbf{39.09} & \textbf{44.84} & \textbf{51.59} & \textbf{53.87} & \textbf{33.04} & \textbf{27.81} & \textbf{22.02} & \textbf{16.52} & \textbf{10.94} \\ \hline
\multirow{2}{*}{OmegaT}       & Impact Miner                 & 44.34          & 50.43          & 53.66          & 56.71          & 61.63          & 26.54          & 22.76          & 19.42          & 16.21          & 13.11          \\ \cline{2-12}
                              & \textbf{Our method}          & \textbf{51.39} & \textbf{54.93} & \textbf{58.01} & \textbf{59.82} & \textbf{61.63} & \textbf{29.45} & \textbf{24.35} & \textbf{21.10} & \textbf{18.61} & \textbf{13.11} \\ \hline
\end{tabular}
\end{scriptsize}
\end{center}
\end{table}}
\par{综上所述，本文提出的基于历史修改模式的影响分析辅助方法在多个项目上能提升传统影响分析工具的效果，验证了本文方法的有效性。}
\par{\textbf{研究问题2：结构耦合关系相似程度是否影响召回率和精确率？}}
\par{对于第二个研究问题，我们以$JRipples$为传统影响分析工具在3个项目上测试不同结构耦合关系相似程度对召回率和精确率的影响。如本文2.5.2节所述，相似度阈值为$\eta$，当提交中关键类和一个非关键类的耦合关系与修改类与一个初始影响集中影响类的耦合关系的相似度大于阈值，认为修改类的修改影响会传播给该影响类，并增加该影响类的分数。实验测试不同$\eta$下影响分析的召回率和精确率。实验结果如表\ref{yuzhi}所示，我们可以发现当相似度阈值$\eta$从0.3，0.5，0.8一次增加时，影响分析的召回率和精确率在不断提升，但$\eta$从0.8增加到0.9时，影响分析的召回率和精确率是下降的。同时我们可以发现，$\eta$取值为0.3时，影响分析效果低于$JRipples$，说明实验对$JRipples$ 产生的初始影响集产生负面调整。
% Please add the following required packages to your document preamble:
% \usepackage{multirow}
\begin{table}[t]
\begin{center}
\begin{scriptsize}
\caption{不同相似阈值$\eta$下实验结果}
\label{yuzhi}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|}
\hline
\multirow{2}{*}{\textbf{项目名}} & \multirow{2}{*}{\textbf{方法}}         & \multirow{2}{*}{\textbf{$\eta$}} & \multicolumn{5}{c|}{\textbf{召回率（\%）}}                                              & \multicolumn{5}{c|}{\textbf{精确率（\%）}}                                            \\ \cline{4-13}
                              &                                      &                                  & \textbf{5}     & \textbf{10}    & \textbf{20}    & \textbf{30}    & \textbf{50}    & \textbf{5}     & \textbf{10}    & \textbf{20}    & \textbf{30}   & \textbf{50}   \\ \hline
\multirow{5}{*}{jEdit}        & JRipples                             &                                  & 23.59          & 34.18          & 43.77          & 47.28          & 50.10          & 16.15          & 11.15          & 6.90           & 5.19          & 3.31          \\ \cline{2-13}
                              & \multirow{4}{*}{\textbf{Our method}} & 0.3                              & 17.23          & 27.32          & 35.11          & 42.65          & 50.10          & 13.17          & 9.88           & 6.34           & 5.19          & 3.31          \\ \cline{3-13}
                              &                                      & 0.5                              & 23.62          & 33.75          & 42.68          & 46.44          & 50.10          & 16.21          & 11.66          & 6.90           & 5.24          & 3.31          \\ \cline{3-13}
                              &                                      & \textbf{0.8}                     & \textbf{29.41} & \textbf{37.23} & \textbf{44.83} & \textbf{48.34} & \textbf{50.10} & \textbf{18.07} & \textbf{12.12} & \textbf{7.02}  & \textbf{5.32} & \textbf{3.31} \\ \cline{3-13}
                              &                                      & 0.9                              & 26.67          & 35.54          & 43.12          & 47.19          & 50.10          & 16.46          & 12.08          & 6.95           & 5.32          & 3.31          \\ \hline
\multirow{5}{*}{JHotDraw}     & JRipples                             &                                  & 16.72          & 21.02          & 24.26          & 27.11          & 29.30          & 13.07          & 11.55          & 9.87           & 8.05          & 5.15          \\ \cline{2-13}
                              & \multirow{4}{*}{\textbf{Our method}} & 0.3                              & 13.31          & 16.76          & 20.01          & 25.59          & 29.30          & 9.81           & 7.65           & 6.02           & 5.52          & 5.15          \\ \cline{3-13}
                              &                                      & 0.5                              & 16.76          & 20.87          & 25.35          & 28.81          & 29.30          & 12.84          & 11.41          & 9.25           & 8.13          & 5.15          \\ \cline{3-13}
                              &                                      & \textbf{0.8}                     & \textbf{18.25} & \textbf{24.54} & \textbf{27.24} & \textbf{28.12} & \textbf{29.30} & \textbf{14.25} & \textbf{12.54} & \textbf{11.06} & \textbf{8.49} & \textbf{5.15} \\ \cline{3-13}
                              &                                      & 0.9                              & 17.09          & 23.84          & 25.59          & 27.36          & 29.30          & 13.57          & 12.38          & 10.88          & 8.21          & 5.15          \\ \hline
\multirow{5}{*}{HSQLDB}       & JRipples                             &                                  & 12.82          & 16.86          & 17.29          & 18.34          & 18.82          & 11.07          & 8.39           & 4.38           & 3.21          & 2.04          \\ \cline{2-13}
                              & \multirow{4}{*}{\textbf{Our method}} & 0.3                              & 8.54           & 12.10          & 15.89          & 16.34          & 18.82          & 8.95           & 6.34           & 3.21           & 2.54          & 2.04          \\ \cline{3-13}
                              &                                      & 0.5                              & 11.99          & 15.88          & 17.16          & 17.55          & 18.82          & 11.15          & 8.41           & 4.25           & 3.21          & 2.04          \\ \cline{3-13}
                              &                                      & \textbf{0.8}                     & \textbf{15.10} & \textbf{18.45} & \textbf{17.39} & \textbf{18.34} & \textbf{18.82} & \textbf{13.77} & \textbf{9.26}  & \textbf{4.44}  & \textbf{3.21} & \textbf{2.04} \\ \cline{3-13}
                              &                                      & 0.9                              & 15.04          & 17.84          & 17.99          & 18.29          & 18.82          & 12.67          & 9.06           & 4.35           & 3.23          & 2.04          \\ \hline
\end{tabular}
\end{scriptsize}
\end{center}
\end{table}}
\par{为了进一步分析耦合关系相似度如何影响实验结果，我们随机从实验数据中提取一个提交的影响分析结果进行分析（如图\ref{fig:eta}所示），我们可以发现阈值$\eta$取值越低，影响集中每个类的最终的得分越高，说明类被调整的次数也越多，$\eta$取值越高，则相反。这是由于阈值低的时候，能找到更多相似耦合关系对（关键类-非关键类），这同时也造成了更多的负面调整。结合图中实际影响类在不同影响集中的位置可以发现，阈值越高，实际影响类被有效调整几率越高，排名越有可能提高。但是，阈值太高时（例如$\eta$取0.9），由于符合相似性的耦合关系对太少，导致影响集得到的调整也变少。
\begin{figure}[!t]
\centering
\includegraphics[width=5.5in]{myfigure/eta1.pdf}
\caption{不同$\eta$下影响集优化示例}
\label{fig:eta}
\end{figure}}
\par{综上所述，结构耦合关系的相似性可以用于映射修改模式，当相似度较低时，会对影响集产生较大调整，包括大量负面调整，当相似度过高时，则对影响集产生的调整过小。实验验证，当相似度阈值$\eta$取值为0.8时，基于机构耦合关系相似性的历史修改模式映射取得最好效果。}
\subsection{本章小结}
\par{在本章中，我们提出了一种基于历史修改模式的影响分析辅助方法，该方法利用开源项目的历史提交数据构建提交语料库；再借助词向量模型检索与当前修改任务的相似提交，并通过关键类判别技术识别提交中的关键类；最后，基于相似提交中关键类和非关键类之间与当前修改类与其他类之间的结构耦合关系相似性，将提交中关键类的修改模式映射回修改类，完成对初始影响集的优化。在实验中，我们在8个开源项目上进行了验证。实验结果表明我们的方法能有效提高传统影响分析的影响集的召回率和精确率。同时，我们也验证了结构耦合关系相似性对于历史修改模式映射的影响。}
% Please add the following required packages to your document preamble:
% \usepackage{multirow}
\begin{table}[]
\begin{center}
\begin{scriptsize}
\begin{tabular}{ccccccccccccc}
\hline
\multirow{2}{*}{\textbf{项目名}} & \multirow{2}{*}{\textbf{方法}}         & \multirow{2}{*}{\textbf{$\eta$}} & \multicolumn{5}{c}{\textbf{召回率（\%）}}                                               & \multicolumn{5}{c}{\textbf{精确率（\%）}}                                             \\
                              &                                      &                                  & \textbf{5}     & \textbf{10}    & \textbf{20}    & \textbf{30}    & \textbf{50}    & \textbf{5}     & \textbf{10}    & \textbf{20}    & \textbf{30}   & \textbf{50}   \\ \hline
\multirow{5}{*}{jEdit}        & JRipples                             &                                  & 23.59          & 34.18          & 43.77          & 47.28          & 50.10          & 16.15          & 11.15          & 6.90           & 5.19          & 3.31          \\
                              & \multirow{4}{*}{\textbf{Our method}} & 0.3                              & 17.23          & 27.32          & 35.11          & 42.65          & 50.10          & 13.17          & 9.88           & 6.34           & 5.19          & 3.31          \\
                              &                                      & 0.5                              & 23.62          & 33.75          & 42.68          & 46.44          & 50.10          & 16.21          & 11.66          & 6.90           & 5.24          & 3.31          \\
                              &                                      & \textbf{0.8}                     & \textbf{29.41} & \textbf{37.23} & \textbf{44.83} & \textbf{48.34} & \textbf{50.10} & \textbf{18.07} & \textbf{12.12} & \textbf{7.02}  & \textbf{5.32} & \textbf{3.31} \\
                              &                                      & 0.9                              & 26.67          & 35.54          & 43.12          & 47.19          & 50.10          & 16.46          & 12.08          & 6.95           & 5.32          & 3.31          \\
\multirow{5}{*}{JHotDraw}     & JRipples                             &                                  & 16.72          & 21.02          & 24.26          & 27.11          & 29.30          & 13.07          & 11.55          & 9.87           & 8.05          & 5.15          \\
                              & \multirow{4}{*}{\textbf{Our method}} & 0.3                              & 13.31          & 16.76          & 20.01          & 25.59          & 29.30          & 9.81           & 7.65           & 6.02           & 5.52          & 5.15          \\
                              &                                      & 0.5                              & 16.76          & 20.87          & 25.35          & 28.81          & 29.30          & 12.84          & 11.41          & 9.25           & 8.13          & 5.15          \\
                              &                                      & \textbf{0.8}                     & \textbf{18.25} & \textbf{24.54} & \textbf{27.24} & \textbf{28.12} & \textbf{29.30} & \textbf{14.25} & \textbf{12.54} & \textbf{11.06} & \textbf{8.49} & \textbf{5.15} \\
                              &                                      & 0.9                              & 17.09          & 23.84          & 25.59          & 27.36          & 29.30          & 13.57          & 12.38          & 10.88          & 8.21          & 5.15          \\
\multirow{5}{*}{HSQLDB}       & JRipples                             &                                  & 12.82          & 16.86          & 17.29          & 18.34          & 18.82          & 11.07          & 8.39           & 4.38           & 3.21          & 2.04          \\
                              & \multirow{4}{*}{\textbf{Our method}} & 0.3                              & 8.54           & 12.10          & 15.89          & 16.34          & 18.82          & 8.95           & 6.34           & 3.21           & 2.54          & 2.04          \\
                              &                                      & 0.5                              & 11.99          & 15.88          & 17.16          & 17.55          & 18.82          & 11.15          & 8.41           & 4.25           & 3.21          & 2.04          \\
                              &                                      & \textbf{0.8}                     & \textbf{15.10} & \textbf{18.45} & \textbf{17.39} & \textbf{18.34} & \textbf{18.82} & \textbf{13.77} & \textbf{9.26}  & \textbf{4.44}  & \textbf{3.21} & \textbf{2.04} \\
                              &                                      & 0.9                              & 15.04          & 17.84          & 17.99          & 18.29          & 18.82          & 12.67          & 9.06           & 4.35           & 3.23          & 2.04          \\ \hline
\end{tabular}
\end{scriptsize}
\end{center}
\end{table}
