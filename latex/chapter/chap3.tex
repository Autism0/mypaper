
\rhead{\xiaowuhao\sectionindex\quad基于可判别特征的代码修改完成周期预测}
\section{基于可判别特征的代码修改完成周期预测}
\par{一项软件代码修改工作通常包含多次“修改-审核-再修改”的过程，开发人员在修改完代码后需提交给审核人员，即一项代码修改工作完成的标志是通过代码审核人员的审查。代码审核不通过，则开发人员需对代码进行再次改进。因此，一项代码修改任务往往经过了多次的代码审核环节，代码审核的次数也能体现该任务周期的长短。审核次数的预测有助于开发人员及时发现代码修改中存在的问题，以及有助于项目管理人员重新评估该代码修改任务的工作量和难度，并及时做出调整，如增加开发人员等，进而缩短代码修改任务的完成周期。本文以代码审核次数表示代码修改完成周期的长短，并从代码审核数据中提取可判别特征，训练机器学习模型，用于预测代码修改的审核次数。我们的方法从代码审核数据中提取代码审核信息、代码耦合信息以及代码修改信息作为可判别特征，再使用集成学习方法融合多个机器学习模型得到我们的分类模型。}
\subsection{问题描述及方法总览}
\par{代码修改完成周期指的是开发人员完成一项代码修改工作的时间周期，而开发人员将他们的代码提交到软件项目之前需要通过代码审核人员的审查，因此，在本文中，我们通过代码审核次数来评估代码修改完成周期。如图\ref{fig:review-day}所示，我们从1000条代码审核数据中调研了代码修改工作中代码审核次数与修改完成时间的关系，从中可以发现，代码审核次数与代码修改完成时间之间存在强相关性，代码审核次数增加意味着代码修改完成时间增加。图\ref{fig:review-day}中折线的点代表着该审核次数下修改任务完成时间的平均值，修改完成时间的平均值与代码审核次数存在同步增加的趋势，代码修改完成时间的长短可以由代码审核次数反应。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/review-day.png}
\caption{代码审核次数与修改完成周期关联图}
\label{fig:review-day}
\end{figure}}

\par{图\ref{fig:method2}展示了本文方法的总览。该方法主要分为三个阶段：代码审核数据收集阶段、可判别特征提取阶段和机器学习模型构建阶段。代码审核软件的广泛使用，使得审核过程中的历史信息更加容易收集。本文从Gerrit代码审核软件中获取开源项目维护过程中代码审核信息，主要包括审核文本信息以及代码修改信息。在可判别特征提取阶段，我们从代码审核数据中提取审核文本特征、代码耦合特征以及代码修改特征。审核文本特征用于衡量代码审核过程中的非修改因素，包括审核人员信息、审核提交时间、项目信息等。代码耦合特征用于衡量修改代码实体之间的结构耦合特征，与修改复杂程度关联。代码修改特征用于衡量修改内容以及修改的工作量等。在模型构建阶段，本文测试多个机器学习模型的预测效果，并通过集成学习方法Stacking 对多个模型进行融合，实现本文的修改完成周期预测模型。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/method2.pdf}
\caption{基于可判别特征的代码修改完成周期预测方法总览}
\label{fig:method2}
\end{figure} }
\subsection{可判别特征的提取}
\par{本节详细介绍了修改完成周期预测模型的特征提取方法，我们将从三个维度提取特征来描述代码修改工作，这些维度特征为：审核文本特征、代码耦合特征以及代码修改特征。审核文本特征描述代码审核过程中的因素对整个时间周期的影响；代码耦合特征可以刻画该修改工作的复杂度；代码修改特征用于衡量代码修改工作的工作量。}
\subsubsection{代码审核文本特征提取}
\par{代码修改的审核过程中存在诸多非修改因素，这些非修改因素对代码审核的通过率产生了直接的影响。审核人员的工作量和经验、开发人员的经验和参与度会直接关系着代码审核流程的质量\cite{kononenko2015investigating}。原则上，代码审核是一个透明的过程，代码审核应该对提交代码存在的缺陷具有预防性，审核人员的目标是及时评估提交代码的质量，然而，在实践中代码审核的执行过程会受到各种因素的影响\cite{baysal2016investigating}。本文从代码审核文本信息中提取了10种特征，用于描述代码审核过程中各种因素对代码修改完成时间的影响。}
\begin{table}[ht]
\begin{center}
\begin{footnotesize}
\caption{代码审核文本特征及描述}
\label{tf}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{类型}              & \textbf{特征}           & \textbf{符号} & \textbf{描述}             \\ \hline
\multirow{10}{*}{审核文本特征} & Owner                 & $MF_{0}$         & 修改提交的管理人员                \\ \cline{2-4}
                         & Author                & $MF_{1}$         & 修改提交的作者                 \\ \cline{2-4}
                         & Reviewers             & $MF_{2}$         & 修改提交的审核人员               \\ \cline{2-4}
                         & Project               & $MF_{3}$         & 修改所归属的项目                \\ \cline{2-4}
                         & Branch                & $MF_{4}$         & 修改所归属的项目分支              \\ \cline{2-4}
                         & Time                  & $MF_{5}$         & 修改提交的时间                 \\ \cline{2-4}
                         & Revierws\_Num         & $MF_{6}$         & 审核人员的数量                 \\ \cline{2-4}
                         & Author\_Sum           & $MF_{7}$         & 修改提交作者在项目中总的提交次数        \\ \cline{2-4}
                         & Author\_Sum\_M        & $MF_{8}$         & 修改提交作者在项目中近一个月的提交次数     \\ \cline{2-4}
                         & Reviewer\_Author\_Ave & $MF_{9}$         & 相同审核人员和作者的修改的平均审核次数 \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}
\par{本文提取的代码审核文本特征如表\ref{tf}所示。$MF_{0}$表示该修改提交的管理人员，$MF_{1}$表示该修改提交的作者，$MF_{2}$ 表示修改提交的审核人员，我们用这三个特征来描述人力因素对完成周期的影响。通常同个软件项目下的开发人员和审核人员数量有限，不同的审核人员和开发人员对于软件项目熟悉程度的差异会导致软件修改工作所需要时间产生很大差距。同时，我们调研发现，审核人员对缺陷审查具有倾向性，有些审核人员容易忽略一些特定的代码缺陷；不同审核人员提供反馈意见的详细程度也存在差异，将直接影响开发人员的再次修改。$MF_{3}$表示该修改提交归属的项目，$MF_{4}$表示该修改提交所在的项目分支，我们用这两个特征衡量不同项目以及不同分支中代码修改工作的差异。不同项目以及分支中软件实体复杂程度不同，常见修改目标也不同，这些差异将体现在开发人员完成修改工作所需要的时间。另外，我们统计还发现，通常一项修改的审核工作存在多位审核人员，因此，我们收集了所有的审核人员信息，并增加了特征$MF_{6}$，用于标记参与该修改提交的审核人员数量。}
\par{Eyolfson等人\cite{eyolfson2011time}研究了修改的提交时间与提交代码的正确性之间的关系，他们发现在深夜到凌晨4点之间提交的代码更容易出错，同时，在早上7点到中午之间提交的代码错误更少。另外，该研究还发现开发人员提交代码的频率也影响着代码的正确率。参考该研究的结论，我们从代码审核数据中提取了代码提交时间$MF_{5}$以及开发人员在项目中的活跃度特征，活跃度特征通过开发人员在项目中总的提交次数$MF_{7}$和近一个月的提交次数$MF_{8}$ 来衡量。}
\par{我们直接从审核数据中提取的特征为文本特征，在输入预测模型前，需要将文本特征转换成数值特征，常用的编码方法有直接编码和独热编码（one-hot）。以特征$MF_{2}$为例，存在600多个不同的审核人员，使用直接编码的方式，将转换成一维特征和600多种取值；使用独热编码的方式，对于$MF_{2}$特征下600多个可能取值，将产生600 多个二元特征，这些特征互斥且每次仅有一个特征激活，即每个样本仅有少数特征取值为1 （由于一个提交存在多为审核人员），其余特征取值都为0。 两种编码方式都存在明显缺陷，审核人员之间相互独立，而直接编码导致取值相差小的两位审核人员比取值相差大的更加具有相似性，并且直接编码使得不同样本之间的区分度变低；采用独热编码的方式虽然能让特征之间的距离更加合理，但是独热编码会导致特征向量过于稀疏，仅$MF_{2}$经编码后就产生600多个特征，不易于模型训练。针对这些问题，我们对直接编码和独热编码进行了结合和调整。如图\ref{fig:featurecode} 所示，首先，将文本类别特征按首字母划分为26 类，再对每个类下的文本进行直接编码，这种方式增加了样本差异性并且降低了向量维度。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/featurecode.pdf}
\caption{文本类别特征编码示例}
\label{fig:featurecode}
\end{figure}}
\subsubsection{代码结构耦合特征提取}
\par{软件系统经过多年的开发和维护，软件实体间存在复杂的关联关系，在很多情况下，代码修改会在软件实体间传播，从而增加了代码修改的工作的难度。代码修改传播机制\cite{hassan2004predicting} 表明,当两个类之间的结构耦合关系越复杂，则当其中一个类变更时，另一个类存在更大的可能被影响。因此，我们从修改代码中提取结构耦合特征，用于描述代码修改任务的复杂度。}
\par{在代码层次，入度和出度能直接反应一个软件实体的结构耦合特征，入度指当前实体调用修改提交中其他实体的次数；出度指当前实体被修改提交中其他实体调用的次数。修改所涉及的入度和出度能衡量该修改的复杂程度以及时间代价。本文从不同粒度提取软件实体的耦合特征共12维，如表\ref{cf}所示。下面我们按不同粒度分别介绍四种耦合规则，其中符号$C$、$M$、$A$分别表示类、方法、属性。}
\par{\textbf{Class to Class: }根据面向对象编程语法，类层次的耦合关系最常见的有继承（Inheritance）和实现接口（Implementing Interface），$C_{i}$继承$C_{j}$或者实现$C_{j}$的接口，称$C_{j}$为$C_{i}$ 的入度；反之，则称$C_{j}$ 为$C_{i}$ 的出度。本文提取四个特征用于衡量修改提交在类与类层次的耦合特征：特征$CF_{0}$为当前修改提交中类的平均入度；特征$CF_{1}$为当前修改提交中类的入度总和；特征$CF_{2}$为当前修改提交中类的平均出度；特征$CF_{3}$为当前修改提交中类的出度总和。}
\par{\textbf{Method to Class: }在软件实体中，类包含了方法集合和属性集合。类与方法的耦合关系指的是类$C_{i}$的某个方法$M_{i}$中使用了另一个类$C_{j}$，且不是使用$C_{j}$中的方法或属性,这时类$C_{j}$为方法$M_{i}$的入度这种耦合关系常见的实例包括：强制类型转换（Type-Casting），异常抛出类型（Exception Throws），参数类型（Parameter Type），返回类型（Return Type）和类型验证（Instanceof）等。本文提取两个特征衡量修改提交在方法与类层次的耦合特征：特征$CF_{4}$为修改提交中所有方法（\emph{to Class}）的平均入度；特征$CF_{5}$为修改提交中所有方法（\emph{to Class}）的入度总和。}

\begin{table}[h]
\begin{center}
\begin{footnotesize}
\caption{代码结构耦合特征及描述}
\label{cf}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{类型}              & \textbf{特征}                          & \textbf{符号} & \textbf{描述}    \\ \hline
\multirow{12}{*}{代码耦合特征} & \multirow{4}{*}{Class to Class}      & $CF_{0}$          & 修改提交的类与类平均入度   \\ \cline{3-4}
                         &                                      & $CF_{1}$         & 修改提交的类与类入度总和   \\ \cline{3-4}
                         &                                      & $CF_{2}$          & 修改提交的类与类平均出度   \\ \cline{3-4}
                         &                                      & $CF_{3}$          & 修改提交的类与类出度总和   \\ \cline{2-4}
                         & \multirow{2}{*}{Method to Class}     & $CF_{4}$          & 修改提交的方法与类平均入度  \\ \cline{3-4}
                         &                                      & $CF_{5}$          & 修改提交的方法与类入度总和  \\ \cline{2-4}
                         & \multirow{2}{*}{Method to Attribute} & $CF_{6}$          & 修改提交的方法与属性平均入度 \\ \cline{3-4}
                         &                                      & $CF_{7}$          & 修改提交的方法与属性入度总和  \\ \cline{2-4}
                         & \multirow{4}{*}{Method to Method}    & $CF_{8}$          & 修改提交的方法与方法平均入度 \\ \cline{3-4}
                         &                                      & $CF_{9}$          & 修改提交的方法与方法入度总和 \\ \cline{3-4}
                         &                                      & $CF_{10}$         & 修改提交的方法与方法平均出度 \\ \cline{3-4}
                         &                                      & $CF_{11}$         & 修改提交的方法与方法出度总和  \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}
\par{\textbf{Method to Attribute: }在面向对象编码示例中，方法与属性层次也经常存在耦合规则，它指的是位于类$C_{i}$中的某个方法$M_{i}$与类$C_{j}$中某个属性$A_{j}$之间的耦合关系，其中最常见的是静态属性调用（Static Attribute Invoking）。这种情况定义属性$A_{j}$为方法$M_{i}$的入度，我们提取两个特征用于描述方法与属性之间的耦合关系：特征$CF_{6}$表示修改提交中所有方法（\emph{to Attribute}）的平均入度；特征$CF_{7}$为修改提交中所有方法（\emph{to Attribute}）的入度总和。}
\par{\textbf{Method to Method: }方法与方法层次指的是位于不同类$C_{i}$、$C_{j}$的两个方法$M_{i}$和$M_{j}$之间建立的耦合关系，满足这种耦合关系的实例有静态方法调用（Static Method Invoking）,构造方法调用（Construction Method Invoking）等。这种耦合关系具有方法性，因此，我们通过四个特征来表达方法间的耦合特征：特征$CF_{8}$为当前修改提交中方法（\emph{to Method}）的平均入度；特征$CF_{9}$ 为当前修改提交中方法（\emph{to Method}）的入度总和；特征$CF_{10}$为当前修改提交中方法（\emph{to Method}）的平均出度；特征$CF_{11}$为当前修改提交中方法（\emph{to Method}）的出度总和。}
\subsubsection{代码修改特征}
\par{代码修改特征对于代码修改工作的时间代价具有很指向作用，我们从两个维度来提取修改提交中的代码修改特征，分别是代码修改量和代码修改内容。代码修改量能直接体现一项修改的工作量，而代码修改内容则是描述修改需要解决的问题和目标。}
\par{具体地，在代码修改量维度，可以细粒度的划分为涉及修改类的数量、修改方法的数量、修改语句的数量；而从代码变更的类型，还可以划分为增加（\emph{add}）、修改（\emph{change}）和删除（\emph{delete}）。如表\ref{mf}所示，$MF_{0}$表示修改提交中涉及类的数量，而$MF_{1}$、$MF_{2}$、$MF_{3}$则分别表示类型为增加、修改、删除的类的数量。$MF_{4}$表示修改提交中涉及方法的数量，而$MF_{5}$、$MF_{6}$、$MF_{7}$分别表示类型为增加、修改、删除的方法的数量。$MF_{8}$表示修改提交中涉及代码语句的数量，而$MF_{9}$、$MF_{10}$、$MF_{11}$分别表示类型为增加、修改、删除的代码语句的数量。}
\begin{table}[h]
\begin{center}
\begin{footnotesize}
\caption{代码修改量特征及描述}
\label{mf}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{类型}               & \textbf{特征}           & \textbf{符号} & \textbf{描述} \\ \hline
\multirow{15}{*}{代码修改量特征} & \multirow{4}{*}{涉及类}  & $MF_{0}$         & 涉及变更的类的数量   \\ \cline{3-4}
                          &                       & $MF_{1}$          & 增加的类的数量     \\ \cline{3-4}
                          &                       & $MF_{2}$          & 修改的类的数量     \\ \cline{3-4}
                          &                       & $MF_{3}$         & 删除的类的数量     \\ \cline{2-4}
                          & \multirow{4}{*}{涉及方法} & $MF_{4}$         & 涉及变更的方法的数量  \\ \cline{3-4}
                          &                       & $MF_{5}$          & 增加的方法的数量    \\ \cline{3-4}
                          &                       & $MF_{6}$         & 修改的方法的数量    \\ \cline{3-4}
                          &                       & $MF_{7}$         & 删除的方法的数量    \\ \cline{2-4}
                          & \multirow{4}{*}{涉及语句} & $MF_{8}$         & 涉及变更的语句的数量  \\ \cline{3-4}
                          &                       & $MF_{9}$         & 增加的语句的数量    \\ \cline{3-4}
                          &                       & $MF_{10}$       & 修改的语句的数量    \\ \cline{3-4}
                          &                       & $MF_{11}$        & 删除的语句的数量    \\ \cline{2-4}
                          & \multirow{3}{*}{相对修改} & $MF_{12}$        & 相对修改类的数量    \\ \cline{3-4}
                          &                       & $MF_{13}$        & 相对修改方法的数量   \\ \cline{3-4}
                          &                       & $MF_{14}$       & 相对修改语句的数量   \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}
\par{另外，我们还引入代码相对修改量特征，即衡量修改提交的修改量相对于项目中所有提交的平均修改量处于怎样的水平。我们用特征$MF_{12}$描述修改提交的涉及相对修改类的数量；特征$MF{13}$描述修改提交的涉及相对修改方法的数量；特征$MF{14}$描述修改提交的涉及相对修改代码语句的数量。}
\par{在修改内容维度，我们采用与本文2.2节中相同的方法，对所有修改提交中涉及修改的代码片段进行文本预处理，再以预处理后的文本构建语料库。最后，通过Word2vec方法训练词向量模型，以50维的特征向量表示修改提交中的修改内容。}
\subsection{基于集成学习的修改完成周期预测模型}
\par{本节详细介绍基于集成学习的修改完成周期预测模型的构建方法。我们使用集成学习方法组合多个不同类型的机器学习模型，其中，机器学习模型包括：Muti-LR（Multinomial Logistic Regression），XGBoost以及神经网络（Neural Network）。}
\subsubsection{Stacking集成学习方法}
\par{在统计学和机器学习中，集成学习方法通过组合多种学习算法来实现比单一学习算法更好的性能，其中，被组合的模型称为基学习器。集成学习方法将多种及基学习器结合到一个预测模型中，以减少方差和偏差，改进模型的预测效果。集成学习方法可分为Bagging、Boosting和Stacking。Bagging算法采用自举抽样（bootstrap sampling）的方法得到多个子数据集，并行训练多个基学习器，然后通过投票或者平均的方式得到预测结果。Bagging方法将多个预测值平均从而减少模型预测的方差。Boosting方法则采用顺序生成多个基学习器，其主要原理是对于前几个基学习器预测错误的样本给与更多的权重，相当于每个学习器都从之前的学习器种学习并更新错误的预测。}
\par{Bagging和Boosting方法都是组合同类型的基学习器，与Bagging与Boosting不同，Stacking应用于组合不同类型的机器学习算法构建的基学习器。Stacking通过基分类器或者基回归器将多种不同的模型组合在一起。其流程如算法\ref{algo2}所示，第一步，Stacking根据训练数据学习N个基学习器；第二步，用N个基学习器输出的预测值组合新的训练数据；第三部，通过新的训练数据学习最终的模型。}
\begin{table*}[!ht]
\centering
\begin{small}
\label{algo2}
{\footnotesize%
\noindent\begin{tabular*}{135mm}{@{\extracolsep{\fill}}@{}l@{}}
\toprule
\textbf{算法3-1: Stacking集成学习算法}\\
\midrule%
~~1:\quad \textbf{Input}: training data $D=\left \{ x_{i},y_{i} \right \}_{i}^{m}$ \\
~~2:\quad \textbf{Output}: ensemble classifier $H$ \\
~~3:\quad \textbf{\emph{Step 1}}: \emph{learn base-level classifiers}\\
~~4:\quad \textbf{for} \emph{t=}1 to \emph{T} \textbf{do} \\
~~5:\quad\quad learn $h_{t}$ based on $D$ \\
~~6:\quad \textbf{end for}\\
~~7:\quad \textbf{\emph{Step 2}}: \emph{construct new data set of predictions}\\
~~8:\quad\textbf{for} \emph{i=}1 to \emph{m} \textbf{do}\\
~~9:\quad\quad $D_{h}=\left \{ x_{i}{}',y_{i} \right \}$,where $x_{i}{}'=\left \{h_{1}(x_{i}), ..., h_{T}(x_{i})\right \}$\\
10:\quad \textbf{end for}\\
11:\quad\textbf{\emph{Step 3}}: \emph{learn a meta-classifier}\\
12:\quad learn $H$ based on $D_{h}$\\
13:\quad return $H$\\
\bottomrule
\end{tabular*}
} \vspace{-3mm}
\end{small}
\end{table*}
\subsubsection{模型组合方法}
\par{本文正是采用Stacking集成学习方法，对多个分类算法进行组合。Stacking的意义在于从多个模型的预测空间去探索同一个问题，直观地想法是，我们可以用不同类型的机器学习模型来解决同一个学习问题，这些模型能够学习问题的一部分，但不能学习问题的整个空间。因此，我们可以建立多个不同的学习器来提高整体性能。Stacking方法强调基分类器的多样性和差异性，本文通过实验测试比较个种学习算法的性能，选择了Muti-LR、XGBoost和神经网络作为我们Stacking方法的基分类器。}
\par{Muti-LR是多分类的逻辑回归模型，其为逻辑回归模型在类别标签多于两个时的推广，与逻辑回归一样属于线性分类模型。XGBoost本身是一种基于Boosting集成学习方法，近年来，XGBoost在各种数据挖掘领域种都展现了其强大的性能。另外，神经网络和深度学习在软件工程各个方向的应用也取得了出色的效果。本文，我们通过Stacking方法将这三个效果出色且差异大的模型组合新的预测模型，我们的组合原理如图\ref{stacking}所示，Stacking利用N种机器学习算法生成的预测值作为第二层算法的输入，而第二层算法的目标是最优化地组合第一层N个模型的预测值。}
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/stacking.pdf}
\caption{Stacking集成学习方法图示}
\label{stacking}
\end{figure}
