
\rhead{\xiaowuhao\sectionindex\quad基于可判别特征的代码修改完成周期预测}
\section{基于可判别特征的代码修改周期预测}
\par{开发人员在修改完代码后需提交给审核人员，如果代码审核不通过，开发人员需对代码进行再次改进。我们通常认为代码修改工作完成的标志是通过代码审核人员的审查。为了提高代码质量，软件代码修改工作通常包含多次“修改-审核-再修改”的过程，代码审核的次数直接体现该任务周期的长短。因此，我们定义代码修改的时间周期是从修改代码开始至代码通过审核并提交代码库。本文提出一种通过预测代码修改需要经过的“修改-审核”次数来评估该修改时间周期的方法。代码修改周期的预测有助于开发人员及时发现代码修改中存在的问题，以及有助于项目管理人员重新评估该代码修改任务的工作量和难度，并及时做出调整，如增加开发人员等，进而缩短代码修改任务的完成周期。在本文中，我们从代码审核工具中收集开源项目维护过程中的代码修改和审核信息，并从中提取可判别特征用于训练机器学习分类模型。我们从审核原特征（meta-feature）、代码耦合特征（coupling feature）以及代码修改特征（modifying feature）三个维度衡量代码修改及审核中各因素对修改周期的影响。}
\subsection{修改周期预测问题描述及方法总览}
\par{代码修改周期指的是开发人员完成一项代码修改工作的时间周期，包括代码修改阶段及代码审核阶段。其中代码修改阶段所需时间主要由修改难度，修改工作量等因素的影响，代码审核阶段所需时间还受到审核过程中一些非技术因素的影响，例如审核人员、项目信息等。代码修改工作完成的标志是修改的代码经过审查人员的审核，若代码审核不通过，将导致修改周期延长。在代码修改工作中提前预估修改完成周期，有助于开发人员及项目管理人员更加高效的完成代码修改工作。在本文中，我们通过代码“修改-审核”次数来评估代码修改周期。我们从3000条代码审核数据中调研了代码修改工作中代码“修改-审核”次数与其对应的平均修改周期的关系，如图\ref{fig:review-day} 所示。从中可以发现，代码审核次数与代码修改完成时间之间存在强相关性，代码审核次数增加意味着代码修改完成时间增加，代码修改周期的长短可以由代码审核次数反应。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/reviewtime.pdf}
\caption{代码审核次数与平均修改周期关系图}
\label{fig:review-day}
\end{figure}}

\par{图\ref{fig:method2}展示了本文方法的总览。该方法主要分为三个阶段：代码修改和审核数据收集阶段、可判别特征提取阶段和机器学习模型构建阶段。代码审核软件的广泛使用，使得审核过程中的历史信息更加容易收集。本文从Gerrit代码审核软件中获取开源项目维护过程中代码审核数据，主要包括代码审核信息以及代码修改信息。在可判别特征提取阶段，我们从审核原特征、代码耦合特征以及代码修改特征等三个维度提取了40维特征。审核元特征用于衡量代码审核过程中的一些非修改因素，包括审核人员信息、审核提交时间、项目信息等。代码耦合特征用于衡量修改代码实体之间的结构耦合关系，如类之间的继承关系，类与方法的调用关系等，这些结构耦合特征体现了修改工作复杂程度。代码修改特征用于衡量修改内容以及修改的工作量，如代码修改行数，所涉及方法的数量等。在模型训练阶段，本文选用在当前机器学习领域效果突出的XGBoost模型作为预测模型，并对比了多个机器学习模型的预测效果。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/method2-1.pdf}
\caption{基于可判别特征的代码修改完成周期预测方法总览}
\label{fig:method2}
\end{figure} }
\subsection{多维度的可判别特征提取}
\par{本节详细介绍了修改完成周期预测模型中可判别特征提取的方法，我们将从三个不同的维度提取特征来描述代码修改工作，这些维度特征为：审核元特征、代码耦合特征以及代码修改特征。审核元特征描述代码审核过程中的因素对整个时间周期的影响；代码耦合特征从修改代码的结构分析该修改工作的复杂度；代码修改特征用于衡量代码修改工作的工作量以及修改内容。}
\subsubsection{代码审核元特征提取}
\par{原则上，代码审核是一个透明的过程，代码审核应该对提交代码存在的缺陷具有预防性，审核人员的目标是及时评估提交代码的质量，然而，在实践中代码审核的执行过程会受到各种因素的影响\cite{baysal2016investigating}。代码修改过程中的非修改因素指的是除修改代码以外的非技术因素，包括负责修改代码的开发人员、代码审核人员、代码修改任务所归属的项目等，本文中，将这些非修改因素归属为审核元特征。代码修改及审核过程中存在诸多非修改因素，这些非修改因素对代码审核的通过率产生了直接的影响。审核人员的工作量和经验、开发人员的经验和参与度会直接关系到代码审核流程的质量\cite{kononenko2015investigating}。 本文从代码审核数据中提取了10 种特征，用于描述代码修改及审核过程中非修改因素对代码修改完成时间的影响。}
\begin{table}[ht]
\begin{center}
\begin{footnotesize}
\caption{代码审核文本特征及描述}
\label{tf}
\begin{tabular}{|c|c|c|}
\hline
\textbf{类型}                         & \textbf{符号} & \textbf{描述}             \\ \hline
\multirow{10}{*}{审核文本特征} & $MF_{0}$         & 修改提交的管理人员                \\ \cline{2-3}
                         & $MF_{1}$         & 修改提交的作者                 \\ \cline{2-3}
                         & $MF_{2}$         & 修改提交的审核人员               \\ \cline{2-3}
                         & $MF_{3}$         & 修改所归属的项目                \\ \cline{2-3}
                         & $MF_{4}$         & 修改所归属的项目分支              \\ \cline{2-3}
                         & $MF_{5}$         & 修改提交的时间                 \\ \cline{2-3}
                         & $MF_{6}$         & 审核人员的数量                 \\ \cline{2-3}
                         & $MF_{7}$         & 修改提交作者在项目中总的提交次数        \\ \cline{2-3}
                         & $MF_{8}$         & 修改提交作者在项目中近一个月的提交次数     \\ \cline{2-3}
                         & $MF_{9}$         & 相同审核人员和作者的修改的平均审核次数 \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}
\par{本文提取的代码审核元特征如表\ref{tf}所示。$MF_{0}$表示该修改提交的管理人员，$MF_{1}$表示该修改提交的作者，$MF_{2}$ 表示修改提交的审核人员，我们用这三个特征来描述人力因素对完成周期的影响。通常同个软件项目下的开发人员和审核人员数量有限，不同的审核人员和开发人员对于软件项目熟悉程度的差异会导致软件修改工作所需要时间产生很大差距。同时，我们调研发现，审核人员对缺陷审查具有倾向性，有些审核人员容易忽略一些特定的代码缺陷；不同审核人员提供反馈意见的详细程度也存在差异，将直接影响开发人员的再次修改。$MF_{3}$表示该修改提交归属的项目，$MF_{4}$表示该修改提交所在的项目分支，我们用这两个特征衡量不同项目以及不同分支中代码修改工作的差异。不同项目以及分支中软件实体复杂程度不同，常见修改目标也不同，这些差异将体现在开发人员完成修改工作所需要的时间。另外，我们统计还发现，通常一项修改的审核工作存在多位审核人员，因此，我们收集了所有的审核人员信息，并增加了特征$MF_{6}$，用于标记参与该修改提交的审核人员数量。}
\par{Eyolfson等人\cite{eyolfson2011time}研究了修改的提交时间与提交代码的正确性之间的关系，他们发现在深夜到凌晨4点之间提交的代码更容易出错，同时，在早上7点到中午之间提交的代码错误更少。另外，该研究还发现开发人员提交代码的频率也影响着代码的正确率。参考该研究的结论，我们从代码审核数据中提取了代码提交时间$MF_{5}$以及开发人员在项目中的活跃度特征，活跃度特征通过开发人员在项目中总的提交次数$MF_{7}$和近一个月的提交次数$MF_{8}$ 来衡量。}
\par{我们直接从审核数据中提取的特征为文本特征，如人名，项目名等。在输入预测模型前，需要将文本特征转换成数值特征，常用的编码方法有直接编码和独热编码（one-hot）。以特征$MF_{2}$为例，存在600多个不同的审核人员，使用直接编码的方式，将转换成一维特征和600多种取值；使用独热编码的方式，对于$MF_{2}$特征下600多个可能取值，将产生600 多个二元特征，这些特征互斥且每次仅有一个特征激活，即每个样本仅有少数特征取值为1 （由于一个提交存在多为审核人员），其余特征取值都为0。 两种编码方式都存在明显缺陷，审核人员之间相互独立，而直接编码导致取值相差小的两位审核人员比取值相差大的更加具有相似性，并且直接编码使得不同样本之间的区分度变低；采用独热编码的方式虽然能让特征之间的距离更加合理，但是独热编码会导致特征向量过于稀疏，仅$MF_{2}$经编码后就产生600多个特征，不易于模型训练。针对这些问题，我们对直接编码和独热编码进行了结合和调整。如图\ref{fig:featurecode} 所示，首先，将文本类别特征按首字母划分为26 类，再对每个类下的文本进行直接编码，这种方式增加了样本差异性并且降低了向量维度。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/featurecode.pdf}
\caption{文本类别特征编码示例}
\label{fig:featurecode}
\end{figure}}
\subsubsection{代码结构耦合特征提取}
\par{软件系统经过多年的开发和维护，软件实体间存在复杂的关联关系。由于这些关联关系，代码修改会在软件实体间传播，从而增加了代码修改的工作的难度。根据代码修改传播机制\cite{hassan2004predicting} ，如果两个类之间的结构耦合关系越复杂，则当其中一个类变更时，另一个类存在更大的可能被影响。因此，我们从修改代码中提取结构耦合特征，用于描述代码修改任务的复杂度。}
\par{在软件实体间，入度和出度是反应软件实体的结构耦合特征的有效方式，入度指当前实体引用修改提交中其他实体的次数；出度指的是其他软件实体引用当前实体的次数。修改所涉及的入度和出度能衡量该修改的复杂程度以及时间代价。本文从不同粒度提取代码实体之间的耦合特征共12维，如表\ref{cf}所示。下面我们按不同粒度分别介绍四种耦合规则，其中符号$C$、$M$、$A$分别表示类、方法、属性。}

\begin{table}[h]
\begin{center}
\begin{footnotesize}
\caption{代码结构耦合特征及描述}
\label{cf}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{类型}              & \textbf{层次}                          & \textbf{符号} & \textbf{描述}    \\ \hline
\multirow{12}{*}{代码耦合特征} & \multirow{4}{*}{Class to Class}      & $CF_{0}$          & 修改提交的类与类平均入度   \\ \cline{3-4}
                         &                                      & $CF_{1}$         & 修改提交的类与类入度总和   \\ \cline{3-4}
                         &                                      & $CF_{2}$          & 修改提交的类与类平均出度   \\ \cline{3-4}
                         &                                      & $CF_{3}$          & 修改提交的类与类出度总和   \\ \cline{2-4}
                         & \multirow{2}{*}{Method to Class}     & $CF_{4}$          & 修改提交的方法与类平均入度  \\ \cline{3-4}
                         &                                      & $CF_{5}$          & 修改提交的方法与类入度总和  \\ \cline{2-4}
                         & \multirow{2}{*}{Method to Attribute} & $CF_{6}$          & 修改提交的方法与属性平均入度 \\ \cline{3-4}
                         &                                      & $CF_{7}$          & 修改提交的方法与属性入度总和  \\ \cline{2-4}
                         & \multirow{4}{*}{Method to Method}    & $CF_{8}$          & 修改提交的方法与方法平均入度 \\ \cline{3-4}
                         &                                      & $CF_{9}$          & 修改提交的方法与方法入度总和 \\ \cline{3-4}
                         &                                      & $CF_{10}$         & 修改提交的方法与方法平均出度 \\ \cline{3-4}
                         &                                      & $CF_{11}$         & 修改提交的方法与方法出度总和  \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}
\par{\textbf{Class to Class: }根据面向对象编程语法，类层次的耦合关系最常见的有继承（Inheritance）和实现接口（Implementing Interface），$C_{i}$继承$C_{j}$或者实现$C_{j}$的接口，称$C_{j}$为$C_{i}$ 的入度；反之，则称$C_{j}$ 为$C_{i}$ 的出度。本文提取四个特征用于衡量修改提交在类与类层次的耦合特征：特征$CF_{0}$为当前修改提交中类的平均入度；特征$CF_{1}$为当前修改提交中类的入度总和；特征$CF_{2}$为当前修改提交中类的平均出度；特征$CF_{3}$为当前修改提交中类的出度总和。}
\par{\textbf{Method to Class: }在软件实体中，类包含了方法集合和属性集合。类与方法的耦合关系指的是，在类$C_{i}$的某个方法$M_{i}$中使用了另一个类$C_{j}$，且不是使用$C_{j}$中的方法或属性，这时类$C_{j}$为方法$M_{i}$的入度这种耦合关系常见的实例包括：强制类型转换（Type-Casting），异常抛出类型（Exception Throws），参数类型（Parameter Type），返回类型（Return Type）和类型验证（Instanceof）等。本文提取两个特征衡量修改提交在方法与类层次的耦合特征：特征$CF_{4}$为修改提交中所有方法（\emph{to Class}）的平均入度；特征$CF_{5}$为修改提交中所有方法（\emph{to Class}）的入度总和。}

\par{\textbf{Method to Attribute: }在面向对象编码示例中，方法与属性层次也经常存在耦合规则，它指的是位于类$C_{i}$中的某个方法$M_{i}$与类$C_{j}$中某个属性$A_{j}$之间的耦合关系，其中最常见的是静态属性调用（Static Attribute Invoking）。这种情况定义属性$A_{j}$为方法$M_{i}$的入度，我们提取两个特征用于描述方法与属性之间的耦合关系：特征$CF_{6}$表示修改提交中所有方法（\emph{to Attribute}）的平均入度；特征$CF_{7}$为修改提交中所有方法（\emph{to Attribute}）的入度总和。}
\par{\textbf{Method to Method: }方法与方法层次指的是位于不同类$C_{i}$、$C_{j}$的两个方法$M_{i}$和$M_{j}$之间建立的耦合关系，满足这种耦合关系的实例有静态方法调用（Static Method Invoking），构造方法调用（Construction Method Invoking）等。这种耦合关系具有方法性，因此，我们通过四个特征来表达方法间的耦合特征：特征$CF_{8}$为当前修改提交中方法（\emph{to Method}）的平均入度；特征$CF_{9}$ 为当前修改提交中方法（\emph{to Method}）的入度总和；特征$CF_{10}$为当前修改提交中方法（\emph{to Method}）的平均出度；特征$CF_{11}$为当前修改提交中方法（\emph{to Method}）的出度总和。}
\subsubsection{代码修改特征}
\par{代码修改特征对于代码修改工作的时间代价具有很强的指向作用，我们从两个维度来提取修改提交中的代码修改特征，分别是代码修改量和代码修改内容。代码修改量直接体现了一项修改的工作量，而代码修改内容则是描述修改需要解决的问题和目标。代码修改量与修改内容都直接影响着代码修改阶段以及代码审核阶段所需的时间。}
\par{具体地，在代码修改量维度，可以细粒度地划分为类层次的修改量、方法层次的修改量、语句层次的修改量；而从代码变更的类型，还可以划分为增加（\emph{add}）、修改（\emph{change}）和删除（\emph{delete}）。如表\ref{mf}所示，本文提取了18维特征用于描述代码修改任务中修改量。}
\par{特征$MF_{0}\sim MF_{2}$表示涉及变更的代码语句数量，包括新增代码语句的数量、修改代码语句的数量和删除代码语句的数量。特征$MF_{3}\sim MF_{6}$描述涉及修改的类的数量，分别代表新增类的数量、修改类的数量、删除类的数量以及类名修改的数量。其中类名的修改会引入一系列类引用上的修改问题。在方法层次，特征$MF_{7}\sim MF_{10}$分别代表方法新增的数量，方法删除的数量，方法名变更数量以及方法返回类型修改的数量。特征$MF_{11}\sim MF_{14}$代表涉及变更的参数数量，包括参数类型修改，参数名修改以及参数增加和删除。特征$MF_{15}\sim MF_{16}$分别表示属性类型与属性名的修改。另外，我们还发现提交表达式的修改是代码修改工作中频率较高的修改类型，并且条件语句的修改会对代码流程产生较大影响，因此我们用特征$MF_{17}$表示涉及修改的条件表达式的数量。}

\begin{table}[h]
\begin{center}
\begin{footnotesize}
\caption{代码修改量特征及描述}
\label{mf}
\begin{tabular}{|c|c|c|}
\hline
\textbf{类型}               & \textbf{符号} & \textbf{描述} \\ \hline
\multirow{18}{*}{代码修改量特征} & $MF_{0}$         & 新增代码行数      \\ \cline{2-3}
                          & $MF_{1}$         & 修改代码行数      \\ \cline{2-3}
                          & $MF_{2}$        & 删除代码行数      \\ \cline{2-3}
                          & $MF_{3}$         & 新增类的数量      \\ \cline{2-3}
                          & $MF_{4}$         & 修改类的数量      \\ \cline{2-3}
                          & $MF_{5}$         & 删除类的数量      \\ \cline{2-3}
                          & $MF_{6}$         & 重命名类的数量     \\ \cline{2-3}
                          & $MF_{7}$         & 新增方法的数量     \\ \cline{2-3}
                          & $MF_{8}$         & 删除方法的数量     \\ \cline{2-3}
                          & $MF_{9}$         & 重命名方法数量     \\ \cline{2-3}
                          & $MF_{10}$        & 变更返回类型的方法数量 \\ \cline{2-3}
                          & $MF_{11}$        & 参数类型变更的数量   \\ \cline{2-3}
                          & $MF_{12}$        & 参数名变更数量     \\ \cline{2-3}
                          & $MF_{13}$        & 新增参数数量      \\ \cline{2-3}
                          & $MF_{14}$        & 删除参数数量      \\ \cline{2-3}
                          & $MF_{15}$        & 属性名变更数量     \\ \cline{2-3}
                          & $MF_{16}$        & 属性类型变更数量    \\ \cline{2-3}
                          & $MF_{17}$        & 条件表达式变更数量   \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}

\par{在修改内容维度，我们采用与本文2.2节中相同的方法。我们对所有修改提交中涉及修改的代码片段进行文本预处理，再以预处理后的文本构建语料库。最后，通过Word2vec方法训练词向量模型，以50维的特征向量表示修改提交中的修改内容。}
\subsection{机器学习算法选择及模型评估方法}
\par{本文提出的代码修改周期预测方法基于有监督机器学习算法，具体地，我们通过代码修改的“修改-审核”次数评估代码修改的周期长短。我们将代码修改周期预测视为分类问题，然后按时间长短将代码修改周期划分为三个层次：较短、一般和较长，分别对应时间为1天内、一周内和一周以上。结合图\ref{fig:review-day}，我们根据时间长短将“修改-审核”次数与修改周期长短相对应。我们从开源项目的历史修改和审核数据中提取审核元特征，代码耦合特征以及代码修改特征，再基于这些特征训练机器学习模型。最后使用训练好的模型对新的修改任务预测修改周期。}
\subsubsection{机器学习算法选择}
\par{在本文中，采用有监督机器学习算法。常见的分类算法有逻辑回归（\emph{LR}，Logistic Regression），支持向量机（\emph{SVM}，Support Vector Machines），随机森林（\emph{RF}，Random Forest），人工神经网络（\emph{ANN}，Artificial Neural Networks）以及\emph{XGBoost}（Extreme Gradient Booting）。在实验中，我们对比各种分类算法在两个开源项目中的分类效果后，选择表现最优的\emph{XGBoost} 作为我们的修改周期预测模型。}
\par{\emph{XGBoost} 是梯度提升树模型（Gradient Boosting Trees）的一种高效实现方式。\emph{XGBoost} 集成了K颗\emph{CART}树（Classification and Regression Trees）\{$Tr_{1}(x_{1},y_{1})$, $Tr_{2}(x_{2},y_{2})$..., $Tr_{k}(x_{k},y_{k})$\}。其中，$x_{i}$ 表示第 $i^{th}$ 个样本的特征，$y_{i}$ 则表示该样本对应的标签。\emph{CART} 树将分配给每个叶子节点一个分数，而最终的预测结果将由所有\emph{CART} 树上对应叶子节点的分数通过加法模型得到，如公式所示\ref{xgb1}}。
\begin{equation}
    \hat{y}=\sum_{k=1}^{K}f_{k}(x_{i}),\quad\quad f_{k}\in F \label{xgb1}
\end{equation}
\par{在上述公式中，$f_{k}(x_{i})$ 为第 $k^{th}$ 颗树的预测分数，$F$ 则代表函数空间中所包含的所有树模型。相比于传统的梯度提升树模型，\emph{XGBoost} 一个重要的改进是在目标函数中加入了正则项。公式\ref{xgb2}为\emph{XGBoost}的目标函数。}
\begin{equation}
Obj(\Theta )=\sum_{i=1}^{n}l(y_{i},\hat{y_{i}})+\sum_{k}^{K}\Omega (f_{k}) \label{xgb2}
\end{equation}
\par{其中，$l$ 为损失函数，描述的是预测标签 $\hat{y_{i}}$ 与真实标签 $y_{i}$ 之间的误差。而在表达式 $\sum_{k}^{K}\Omega (f_{k})$ 中，$\Omega (f)=\gamma T+\frac{1}{2}\lambda \sum_{j=1}^{T}\omega _{j}^{2}$ 用于描述模型的复杂度。$T$ 和 $\omega$ 分别表示叶子数量及对应叶子节点上的取值。$\gamma$ 和 $\lambda$ 则用于控制正则化的惩罚程度。}
\subsubsection{模型评估方法}
\par{为了评估修改周期预测模型的有效性，我们采用了分类模型评价中常用的四个指标：召回率、精确率、准确率以及$F_{1}$值。召回率用于度量模型对特定类别样本的预测安全性，如对一些修改周期较长的样本，是否能准确预测；精确率用于度量分类模型的预测结果的精确性；而准确率及$F_{1}$则考察模型对多个类别预测的综合效果。四个指标的定义如下：
}
\begin{equation}
    precision=\frac{TP}{TP+FP}
\end{equation}
\begin{equation}
    recall=\frac{TP}{TP+FN}
\end{equation}
\begin{equation}
    F_{1}= 2\ast \frac{precision\ast recall}{precision+recall}
\end{equation}
\begin{equation}
    accuracy=  \frac{TP+FN}{TP+FN+TN+FP}
\end{equation}
\par{以二分类为例（多分类视为多个二分类问题），$TP$ 和$TN$ 分别表示正确预测的正样本数量和负样本数量，$FP$ 和$FN$分别表示错误预测的正样本数量和负样本数量。}
\subsection{本章小结}
\par{软件维护中的代码修改工作通常包括了代码修改与代码审核两个阶段，这两个阶段共同决定了完成代码修改工作所需要的时间。在本章，我们提出了一种修改周期的预测方法，我们从代码修改和代码审核两个角度考虑代码修改可能需要的时间长短。具体地，我们从开源项目的历史代码修改数据和代码审核数据中，提取可判别特征，包括代码审核元特征、代码耦合特征及代码修改特征。再基于机器学习算法训练预测模型。该模型对一项代码修改工作预测其可能需要经过“修改- 审核”的次数，再以次数评估其修改周期的长短。}
