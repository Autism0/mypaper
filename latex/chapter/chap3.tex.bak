
\rhead{\xiaowuhao\sectionindex\quad基于可判别特征的代码修改完成周期预测}
\section{基于可判别特征的代码修改周期预测}
\par{软件代码修改工作通常包含多次“修改-审核-再修改”的过程，开发人员在修改完代码后需提交给审核人员，代码审核不通过，则开发人员需对代码进行再次改进。通常认为代码修改工作完成的标志是通过代码审核人员的审查。为了提高代码质量，一项代码修改任务往往经过了多次的代码审核环节，代码审核的次数直接体现该任务周期的长短。因此，我们定义代码修改的时间周期是从修改代码开始至代码通过审核并提交代码库。本文提出一种通过预测代码修改需要经过的审核次数来评估该修改时间周期的方法。代码修改周期的预测有助于开发人员及时发现代码修改中存在的问题，以及有助于项目管理人员重新评估该代码修改任务的工作量和难度，并及时做出调整，如增加开发人员等，进而缩短代码修改任务的完成周期。在本文中，我们从代码审核工具中收集开源项目维护过程中的代码审核信息，并从中提取可判别特征用于训练机器学习分类模型。我们从审核原特征（meta-feature）、代码耦合特征以及代码修改特征三个维度衡量代码修改及审核中各因素对修改周期的影响。实验中，我们在两个开源项目上验证了文中提出的方法。实验结果显示我们的预测方法具有较高的准确性。}
\subsection{问题描述及方法总览}
\par{代码修改周期指的是开发人员完成一项代码修改工作的时间周期，包括代码修改阶段及代码审核阶段。其中代码修改阶段所需时间主要由修改难度，修改工作量等因素的影响，代码审核阶段所需时间还受到审核过程中一些非技术因素的影响，例如审核人员、项目信息等。代码修改工作完成的标志是修改的代码经过审查人员的审核，若代码审核不通过，则将直接影响代码修改周期。在代码修改工作中提前预估修改完成周期，有助于开发人员及项目管理人员更加高效的完成代码修改工作。在本文中，我们通过代码审核次数来评估代码修改周期。我们从3000条代码审核数据中调研了代码修改工作中代码审核次数与其对应的平均修改周期的关系，如图\ref{fig:review-day} 所示。从中可以发现，代码审核次数与代码修改完成时间之间存在强相关性，代码审核次数增加意味着代码修改完成时间增加，代码修改周期的长短可以由代码审核次数反应。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/review-day.png}
\caption{代码审核次数与平均修改周期关系图}
\label{fig:review-day}
\end{figure}}

\par{图\ref{fig:method2}展示了本文方法的总览。该方法主要分为三个阶段：代码审核数据收集阶段、可判别特征提取阶段和机器学习模型构建阶段。代码审核软件的广泛使用，使得审核过程中的历史信息更加容易收集。本文从Gerrit代码审核软件中获取开源项目维护过程中代码审核数据，主要包括代码审核信息以及代码修改信息。在可判别特征提取阶段，我们从审核原特征、代码耦合特征以及代码修改特征等三个维度提取了33维特征。审核元特征用于衡量代码审核过程中的一些非修改因素，包括审核人员信息、审核提交时间、项目信息等。代码耦合特征用于衡量修改代码实体之间的结构耦合关系，如类之间的继承关系，类与方法的调用关系等，这些结构耦合特征体现了修改工作复杂程度。代码修改特征用于衡量修改内容以及修改的工作量，如代码修改行数，所涉及方法的数量等。在模型训练阶段，本文选用在当前机器学习领域效果突出的XGBoost模型作为预测模型，并对比了多个机器学习模型的预测效果。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/method2.pdf}
\caption{基于可判别特征的代码修改完成周期预测方法总览}
\label{fig:method2}
\end{figure} }
\subsection{可判别特征的提取}
\par{本节详细介绍了修改完成周期预测模型的特征提取方法，我们将从三个维度提取特征来描述代码修改工作，这些维度特征为：审核元特征、代码耦合特征以及代码修改特征。审核元特征描述代码审核过程中的因素对整个时间周期的影响；代码耦合特征从修改代码的结构分析该修改工作的复杂度；代码修改特征用于衡量代码修改工作的工作量以及修改内容。}
\subsubsection{代码审核元特征提取}
\par{代码修改过程中的非修改因素指的是除修改代码以外的一些因素代码，包括负责修改代码的开发人员、代码审核人员、代码修改任务所归属的项目等，本文中，将这些非修改因素归属为审核元特征。代码修改及审核过程中存在诸多非修改因素，这些非修改因素对代码审核的通过率产生了直接的影响。审核人员的工作量和经验、开发人员的经验和参与度会直接关系到代码审核流程的质量\cite{kononenko2015investigating}。原则上，代码审核是一个透明的过程，代码审核应该对提交代码存在的缺陷具有预防性，审核人员的目标是及时评估提交代码的质量，然而，在实践中代码审核的执行过程会受到各种因素的影响\cite{baysal2016investigating}。 本文从代码审核数据中提取了10 种特征，用于描述代码修改及审核过程中非修改因素对代码修改完成时间的影响。}
\begin{table}[ht]
\begin{center}
\begin{footnotesize}
\caption{代码审核文本特征及描述}
\label{tf}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{类型}              & \textbf{特征}           & \textbf{符号} & \textbf{描述}             \\ \hline
\multirow{10}{*}{审核文本特征} & Owner                 & $MF_{0}$         & 修改提交的管理人员                \\ \cline{2-4}
                         & Author                & $MF_{1}$         & 修改提交的作者                 \\ \cline{2-4}
                         & Reviewers             & $MF_{2}$         & 修改提交的审核人员               \\ \cline{2-4}
                         & Project               & $MF_{3}$         & 修改所归属的项目                \\ \cline{2-4}
                         & Branch                & $MF_{4}$         & 修改所归属的项目分支              \\ \cline{2-4}
                         & Time                  & $MF_{5}$         & 修改提交的时间                 \\ \cline{2-4}
                         & Revierws\_Num         & $MF_{6}$         & 审核人员的数量                 \\ \cline{2-4}
                         & Author\_Sum           & $MF_{7}$         & 修改提交作者在项目中总的提交次数        \\ \cline{2-4}
                         & Author\_Sum\_M        & $MF_{8}$         & 修改提交作者在项目中近一个月的提交次数     \\ \cline{2-4}
                         & Reviewer\_Author\_Ave & $MF_{9}$         & 相同审核人员和作者的修改的平均审核次数 \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}
\par{本文提取的代码审核元特征如表\ref{tf}所示。$MF_{0}$表示该修改提交的管理人员，$MF_{1}$表示该修改提交的作者，$MF_{2}$ 表示修改提交的审核人员，我们用这三个特征来描述人力因素对完成周期的影响。通常同个软件项目下的开发人员和审核人员数量有限，不同的审核人员和开发人员对于软件项目熟悉程度的差异会导致软件修改工作所需要时间产生很大差距。同时，我们调研发现，审核人员对缺陷审查具有倾向性，有些审核人员容易忽略一些特定的代码缺陷；不同审核人员提供反馈意见的详细程度也存在差异，将直接影响开发人员的再次修改。$MF_{3}$表示该修改提交归属的项目，$MF_{4}$表示该修改提交所在的项目分支，我们用这两个特征衡量不同项目以及不同分支中代码修改工作的差异。不同项目以及分支中软件实体复杂程度不同，常见修改目标也不同，这些差异将体现在开发人员完成修改工作所需要的时间。另外，我们统计还发现，通常一项修改的审核工作存在多位审核人员，因此，我们收集了所有的审核人员信息，并增加了特征$MF_{6}$，用于标记参与该修改提交的审核人员数量。}
\par{Eyolfson等人\cite{eyolfson2011time}研究了修改的提交时间与提交代码的正确性之间的关系，他们发现在深夜到凌晨4点之间提交的代码更容易出错，同时，在早上7点到中午之间提交的代码错误更少。另外，该研究还发现开发人员提交代码的频率也影响着代码的正确率。参考该研究的结论，我们从代码审核数据中提取了代码提交时间$MF_{5}$以及开发人员在项目中的活跃度特征，活跃度特征通过开发人员在项目中总的提交次数$MF_{7}$和近一个月的提交次数$MF_{8}$ 来衡量。}
\par{我们直接从审核数据中提取的特征为文本特征，如人名，项目名等。在输入预测模型前，需要将文本特征转换成数值特征，常用的编码方法有直接编码和独热编码（one-hot）。以特征$MF_{2}$为例，存在600多个不同的审核人员，使用直接编码的方式，将转换成一维特征和600多种取值；使用独热编码的方式，对于$MF_{2}$特征下600多个可能取值，将产生600 多个二元特征，这些特征互斥且每次仅有一个特征激活，即每个样本仅有少数特征取值为1 （由于一个提交存在多为审核人员），其余特征取值都为0。 两种编码方式都存在明显缺陷，审核人员之间相互独立，而直接编码导致取值相差小的两位审核人员比取值相差大的更加具有相似性，并且直接编码使得不同样本之间的区分度变低；采用独热编码的方式虽然能让特征之间的距离更加合理，但是独热编码会导致特征向量过于稀疏，仅$MF_{2}$经编码后就产生600多个特征，不易于模型训练。针对这些问题，我们对直接编码和独热编码进行了结合和调整。如图\ref{fig:featurecode} 所示，首先，将文本类别特征按首字母划分为26 类，再对每个类下的文本进行直接编码，这种方式增加了样本差异性并且降低了向量维度。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/featurecode.pdf}
\caption{文本类别特征编码示例}
\label{fig:featurecode}
\end{figure}}
\subsubsection{代码结构耦合特征提取}
\par{软件系统经过多年的开发和维护，软件实体间存在复杂的关联关系。由于这些关联关系，代码修改会在软件实体间传播，从而增加了代码修改的工作的难度。代码修改传播机制\cite{hassan2004predicting} 表明，当两个类之间的结构耦合关系越复杂，则当其中一个类变更时，另一个类存在更大的可能被影响。因此，我们从修改代码中提取结构耦合特征，用于描述代码修改任务的复杂度。}
\par{在代码层次，入度和出度能直接反应一个软件实体的结构耦合特征，入度指当前实体调用修改提交中其他实体的次数；出度指当前实体被修改提交中其他实体调用的次数。修改所涉及的入度和出度能衡量该修改的复杂程度以及时间代价。本文从不同粒度提取软件实体的耦合特征共12维，如表\ref{cf}所示。下面我们按不同粒度分别介绍四种耦合规则，其中符号$C$、$M$、$A$分别表示类、方法、属性。}

\begin{table}[h]
\begin{center}
\begin{footnotesize}
\caption{代码结构耦合特征及描述}
\label{cf}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{类型}              & \textbf{特征}                          & \textbf{符号} & \textbf{描述}    \\ \hline
\multirow{12}{*}{代码耦合特征} & \multirow{4}{*}{Class to Class}      & $CF_{0}$          & 修改提交的类与类平均入度   \\ \cline{3-4}
                         &                                      & $CF_{1}$         & 修改提交的类与类入度总和   \\ \cline{3-4}
                         &                                      & $CF_{2}$          & 修改提交的类与类平均出度   \\ \cline{3-4}
                         &                                      & $CF_{3}$          & 修改提交的类与类出度总和   \\ \cline{2-4}
                         & \multirow{2}{*}{Method to Class}     & $CF_{4}$          & 修改提交的方法与类平均入度  \\ \cline{3-4}
                         &                                      & $CF_{5}$          & 修改提交的方法与类入度总和  \\ \cline{2-4}
                         & \multirow{2}{*}{Method to Attribute} & $CF_{6}$          & 修改提交的方法与属性平均入度 \\ \cline{3-4}
                         &                                      & $CF_{7}$          & 修改提交的方法与属性入度总和  \\ \cline{2-4}
                         & \multirow{4}{*}{Method to Method}    & $CF_{8}$          & 修改提交的方法与方法平均入度 \\ \cline{3-4}
                         &                                      & $CF_{9}$          & 修改提交的方法与方法入度总和 \\ \cline{3-4}
                         &                                      & $CF_{10}$         & 修改提交的方法与方法平均出度 \\ \cline{3-4}
                         &                                      & $CF_{11}$         & 修改提交的方法与方法出度总和  \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}
\par{\textbf{Class to Class: }根据面向对象编程语法，类层次的耦合关系最常见的有继承（Inheritance）和实现接口（Implementing Interface），$C_{i}$继承$C_{j}$或者实现$C_{j}$的接口，称$C_{j}$为$C_{i}$ 的入度；反之，则称$C_{j}$ 为$C_{i}$ 的出度。本文提取四个特征用于衡量修改提交在类与类层次的耦合特征：特征$CF_{0}$为当前修改提交中类的平均入度；特征$CF_{1}$为当前修改提交中类的入度总和；特征$CF_{2}$为当前修改提交中类的平均出度；特征$CF_{3}$为当前修改提交中类的出度总和。}
\par{\textbf{Method to Class: }在软件实体中，类包含了方法集合和属性集合。类与方法的耦合关系指的是类$C_{i}$的某个方法$M_{i}$中使用了另一个类$C_{j}$，且不是使用$C_{j}$中的方法或属性,这时类$C_{j}$为方法$M_{i}$的入度这种耦合关系常见的实例包括：强制类型转换（Type-Casting），异常抛出类型（Exception Throws），参数类型（Parameter Type），返回类型（Return Type）和类型验证（Instanceof）等。本文提取两个特征衡量修改提交在方法与类层次的耦合特征：特征$CF_{4}$为修改提交中所有方法（\emph{to Class}）的平均入度；特征$CF_{5}$为修改提交中所有方法（\emph{to Class}）的入度总和。}

\par{\textbf{Method to Attribute: }在面向对象编码示例中，方法与属性层次也经常存在耦合规则，它指的是位于类$C_{i}$中的某个方法$M_{i}$与类$C_{j}$中某个属性$A_{j}$之间的耦合关系，其中最常见的是静态属性调用（Static Attribute Invoking）。这种情况定义属性$A_{j}$为方法$M_{i}$的入度，我们提取两个特征用于描述方法与属性之间的耦合关系：特征$CF_{6}$表示修改提交中所有方法（\emph{to Attribute}）的平均入度；特征$CF_{7}$为修改提交中所有方法（\emph{to Attribute}）的入度总和。}
\par{\textbf{Method to Method: }方法与方法层次指的是位于不同类$C_{i}$、$C_{j}$的两个方法$M_{i}$和$M_{j}$之间建立的耦合关系，满足这种耦合关系的实例有静态方法调用（Static Method Invoking）,构造方法调用（Construction Method Invoking）等。这种耦合关系具有方法性，因此，我们通过四个特征来表达方法间的耦合特征：特征$CF_{8}$为当前修改提交中方法（\emph{to Method}）的平均入度；特征$CF_{9}$ 为当前修改提交中方法（\emph{to Method}）的入度总和；特征$CF_{10}$为当前修改提交中方法（\emph{to Method}）的平均出度；特征$CF_{11}$为当前修改提交中方法（\emph{to Method}）的出度总和。}
\subsubsection{代码修改特征}
\par{代码修改特征对于代码修改工作的时间代价具有很指向作用，我们从两个维度来提取修改提交中的代码修改特征，分别是代码修改量和代码修改内容。代码修改量能直接体现一项修改的工作量，而代码修改内容则是描述修改需要解决的问题和目标。代码修改量与修改内容都直接影响着代码修改阶段以及代码审核阶段所需的时间。}
\par{具体地，在代码修改量维度，可以细粒度的划分为涉及修改类的数量、修改方法的数量、修改语句的数量；而从代码变更的类型，还可以划分为增加（\emph{add}）、修改（\emph{change}）和删除（\emph{delete}）。如表\ref{mf}所示，本文提取了18维特征用于描述代码修改任务中修改量。}
\par{特征$MF_{0}\sim MF_{2}$表示涉及变更的代码语句数量，包括新增代码语句的数量、修改代码语句的数量和删除代码语句的数量。特征$MF_{3}\sim MF_{6}$描述涉及修改的类的数量，分别代表新增类的数量、修改类的数量、删除类的数量以及类名修改的数量。其中类名的修改会引入一系列类引用上的修改问题。在方法层次，特征$MF_{7}\sim MF_{10}$分别代表方法新增的数量，方法删除的数量，方法名变更数量以及方法返回类型修改的数量。特征$MF_{11}\sim MF_{14}$代表涉及变更的参数数量，包括参数类型修改，参数名修改以及参数增加和删除。特征$MF_{15}\sim MF_{16}$分别表示属性类型与属性名的修改。另外，我们还发现提交表达式的修改是代码修改工作中频率较高的修改类型，并且条件语句的修改会对代码流程产生较大影响，因此我们用特征$MF_{17}$表示涉及修改的条件表达式的数量。}

\begin{table}[h]
\begin{center}
\begin{footnotesize}
\caption{代码修改量特征及描述}
\label{mf}
\begin{tabular}{|c|c|c|}
\hline
\textbf{类型}               & \textbf{符号} & \textbf{描述} \\ \hline
\multirow{18}{*}{代码修改量特征} & $MF_{0}$         & 新增代码行数      \\ \cline{2-3}
                          & $MF_{1}$         & 修改代码行数      \\ \cline{2-3}
                          & $MF_{2}$        & 删除代码行数      \\ \cline{2-3}
                          & $MF_{3}$         & 新增类的数量      \\ \cline{2-3}
                          & $MF_{4}$         & 修改类的数量      \\ \cline{2-3}
                          & $MF_{5}$         & 删除类的数量      \\ \cline{2-3}
                          & $MF_{6}$         & 重命名类的数量     \\ \cline{2-3}
                          & $MF_{7}$         & 新增方法的数量     \\ \cline{2-3}
                          & $MF_{8}$         & 删除方法的数量     \\ \cline{2-3}
                          & $MF_{9}$         & 重命名方法数量     \\ \cline{2-3}
                          & $MF_{10}$        & 变更返回类型的方法数量 \\ \cline{2-3}
                          & $MF_{11}$        & 参数类型变更的数量   \\ \cline{2-3}
                          & $MF_{12}$        & 参数名变更数量     \\ \cline{2-3}
                          & $MF_{13}$        & 新增参数数量      \\ \cline{2-3}
                          & $MF_{14}$        & 删除参数数量      \\ \cline{2-3}
                          & $MF_{15}$        & 属性名变更数量     \\ \cline{2-3}
                          & $MF_{16}$        & 属性类型变更数量    \\ \cline{2-3}
                          & $MF_{17}$        & 条件表达式变更数量   \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}

\par{在修改内容维度，我们采用与本文2.2节中相同的方法。我们对所有修改提交中涉及修改的代码片段进行文本预处理，再以预处理后的文本构建语料库。最后，通过Word2vec方法训练词向量模型，以50维的特征向量表示修改提交中的修改内容。}
\subsection{机器学习算法选择及实验样本处理}
\par{本文提出的代码修改周期预测方法基于有监督机器学习算法，具体地，我们通过代码修改的审核次数评估代码修改的周期长短。我们将代码修改周期预测视为分类问题，在实验预测中，审核次数被划分为三个区间，分别对应代码修改周期的较短、一般以及较长三个层次。我们从开源项目的历史修改提交数据中提取审核元特征，代码耦合特征以及代码修改特征，再基于这些特征训练机器学习模型。最后使用训练好的模型对新的修改任务预测修改周期。}
\subsection{基于集成学习的修改完成周期预测模型}
\par{本节详细介绍基于集成学习的修改完成周期预测模型的构建方法。我们使用集成学习方法组合多个不同类型的机器学习模型，其中，机器学习模型包括：Muti-LR（Multinomial Logistic Regression），XGBoost以及神经网络（Neural Network）。}
\subsubsection{Stacking集成学习方法}
\par{在统计学和机器学习中，集成学习方法通过组合多种学习算法来实现比单一学习算法更好的性能，其中，被组合的模型称为基学习器。集成学习方法将多种基学习器结合到一个预测模型中，以减少方差和偏差，改进模型的预测效果。集成学习方法可分为Bagging、Boosting和Stacking。Bagging算法采用自举抽样（bootstrap sampling）的方法得到多个子数据集，并行训练多个基学习器，然后通过所有基学习器投票或者取平均值的方式得到预测结果。Bagging方法将多个预测值平均从而减少模型预测的方差。Boosting方法则采用顺序生成多个基学习器，其主要原理是对于前几个基学习器预测错误的样本给与更多的权重，相当于每个学习器都从之前的学习器种学习并更新错误的预测。}
\par{Bagging和Boosting方法都是组合同类型的基学习器，与Bagging与Boosting不同，Stacking应用于组合不同类型的机器学习算法构建的基学习器。Stacking通过基分类器或者基回归器将多种不同的模型组合在一起。其流程如算法\ref{algo2}所示，第一步，Stacking根据训练数据学习N个不同类型的基学习器；第二步，用N个基学习器输出的预测值组合新的训练数据；第三部，通过新的训练数据学习最终的模型。本文正是采用Stacking集成学习方法，对多个分类算法进行组合。}
\begin{table*}[!ht]
\centering
\begin{small}
\label{algo2}
{\footnotesize%
\noindent\begin{tabular*}{135mm}{@{\extracolsep{\fill}}@{}l@{}}
\toprule
\textbf{算法3-1: Stacking集成学习算法}\\
\midrule%
~~1:\quad \textbf{Input}: training data $D=\left \{ x_{i},y_{i} \right \}_{i}^{m}$ \\
~~2:\quad \textbf{Output}: ensemble classifier $H$ \\
~~3:\quad \textbf{\emph{Step 1}}: \emph{learn base-level classifiers}\\
~~4:\quad \textbf{for} \emph{t=}1 to \emph{T} \textbf{do} \\
~~5:\quad\quad learn $h_{t}$ based on $D$ \\
~~6:\quad \textbf{end for}\\
~~7:\quad \textbf{\emph{Step 2}}: \emph{construct new data set of predictions}\\
~~8:\quad\textbf{for} \emph{i=}1 to \emph{m} \textbf{do}\\
~~9:\quad\quad $D_{h}=\left \{ x_{i}{}',y_{i} \right \}$,where $x_{i}{}'=\left \{h_{1}(x_{i}), ..., h_{T}(x_{i})\right \}$\\
10:\quad \textbf{end for}\\
11:\quad\textbf{\emph{Step 3}}: \emph{learn a meta-classifier}\\
12:\quad learn $H$ based on $D_{h}$\\
13:\quad return $H$\\
\bottomrule
\end{tabular*}
} \vspace{-3mm}
\end{small}
\end{table*}
\subsubsection{模型组合方法}
\par{Stacking的意义在于从多个模型的预测空间去探索同一个问题，直观地想法是，我们可以用不同类型的机器学习模型来解决同一个学习问题，这些模型能够学习问题的一部分，但不能学习问题的整个空间。因此，我们可以建立多个不同的学习器来提高整体性能。Stacking方法强调基分类器的多样性和差异性，本文通过实验测试比较个种学习算法的性能，选择了Muti-LR、XGBoost和神经网络作为我们Stacking方法的基分类器。}
\par{Muti-LR是多分类的逻辑回归模型，其为逻辑回归模型在类别标签多于两个时的推广，与逻辑回归一样属于线性分类模型。XGBoost本身是一种基于Boosting集成学习方法，近年来，XGBoost在各种数据挖掘领域种都展现了其强大的性能。另外，神经网络和深度学习在软件工程各个方向的应用也取得了出色的效果。本文，我们通过Stacking方法将这三个效果出色且差异大的模型组合新的预测模型，我们的组合原理如图\ref{stacking}所示，Stacking利用N种机器学习算法生成的预测值作为第二层算法的输入，而第二层算法的目标是最优化地组合第一层N个模型的预测值。}
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/stacking.pdf}
\caption{Stacking集成学习方法图示}
\label{stacking}
\end{figure}
