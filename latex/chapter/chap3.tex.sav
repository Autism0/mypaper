
\rhead{\xiaowuhao\sectionindex\quad基于可判别特征的代码修改完成周期预测}
\section{基于可判别特征的代码修改周期预测}
\par{软件代码修改工作通常包含多次“修改-审核-再修改”的过程，开发人员在修改完代码后需提交给审核人员，代码审核不通过，则开发人员需对代码进行再次改进。通常认为代码修改工作完成的标志是通过代码审核人员的审查。为了提高代码质量，一项代码修改任务往往经过了多次的代码审核环节，代码审核的次数直接体现该任务周期的长短。因此，我们定义代码修改的时间周期是从修改代码开始至代码通过审核并提交代码库。本文提出一种通过预测代码修改需要经过的审核次数来评估该修改时间周期的方法。代码修改周期的预测有助于开发人员及时发现代码修改中存在的问题，以及有助于项目管理人员重新评估该代码修改任务的工作量和难度，并及时做出调整，如增加开发人员等，进而缩短代码修改任务的完成周期。在本文中，我们从代码审核工具中收集开源项目维护过程中的代码审核信息，并从中提取可判别特征用于训练机器学习分类模型。我们从审核原特征（meta-feature）、代码耦合特征以及代码修改特征三个维度衡量代码修改及审核中各因素对修改周期的影响。实验中，我们在两个开源项目上验证了文中提出的方法。实验结果显示我们的预测方法具有较高的准确性。}
\subsection{问题描述及方法总览}
\par{代码修改周期指的是开发人员完成一项代码修改工作的时间周期，包括代码修改阶段及代码审核阶段。其中代码修改阶段所需时间主要由修改难度，修改工作量等因素的影响，代码审核阶段所需时间还受到审核过程中一些非技术因素的影响，例如审核人员、项目信息等。代码修改工作完成的标志是修改的代码经过审查人员的审核，若代码审核不通过，则将直接影响代码修改周期。在代码修改工作中提前预估修改完成周期，有助于开发人员及项目管理人员更加高效的完成代码修改工作。在本文中，我们通过代码审核次数来评估代码修改周期。我们从3000条代码审核数据中调研了代码修改工作中代码审核次数与其对应的平均修改周期的关系，如图\ref{fig:review-day} 所示。从中可以发现，代码审核次数与代码修改完成时间之间存在强相关性，代码审核次数增加意味着代码修改完成时间增加，代码修改周期的长短可以由代码审核次数反应。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/review-day.png}
\caption{代码审核次数与平均修改周期关系图}
\label{fig:review-day}
\end{figure}}

\par{图\ref{fig:method2}展示了本文方法的总览。该方法主要分为三个阶段：代码审核数据收集阶段、可判别特征提取阶段和机器学习模型构建阶段。代码审核软件的广泛使用，使得审核过程中的历史信息更加容易收集。本文从Gerrit代码审核软件中获取开源项目维护过程中代码审核数据，主要包括代码审核信息以及代码修改信息。在可判别特征提取阶段，我们从审核原特征、代码耦合特征以及代码修改特征等三个维度提取了33维特征。审核元特征用于衡量代码审核过程中的一些非修改因素，包括审核人员信息、审核提交时间、项目信息等。代码耦合特征用于衡量修改代码实体之间的结构耦合关系，如类之间的继承关系，类与方法的调用关系等，这些结构耦合特征体现了修改工作复杂程度。代码修改特征用于衡量修改内容以及修改的工作量，如代码修改行数，所涉及方法的数量等。在模型训练阶段，本文选用在当前机器学习领域效果突出的XGBoost模型作为预测模型，并对比了多个机器学习模型的预测效果。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/method2.pdf}
\caption{基于可判别特征的代码修改完成周期预测方法总览}
\label{fig:method2}
\end{figure} }
\subsection{可判别特征的提取}
\par{本节详细介绍了修改完成周期预测模型的特征提取方法，我们将从三个维度提取特征来描述代码修改工作，这些维度特征为：审核元特征、代码耦合特征以及代码修改特征。审核元特征描述代码审核过程中的因素对整个时间周期的影响；代码耦合特征从修改代码的结构分析该修改工作的复杂度；代码修改特征用于衡量代码修改工作的工作量以及修改内容。}
\subsubsection{代码审核元特征提取}
\par{代码修改过程中的非修改因素指的是除修改代码以外的一些因素代码，包括负责修改代码的开发人员、代码审核人员、代码修改任务所归属的项目等，本文中，将这些非修改因素归属为审核元特征。代码修改及审核过程中存在诸多非修改因素，这些非修改因素对代码审核的通过率产生了直接的影响。审核人员的工作量和经验、开发人员的经验和参与度会直接关系到代码审核流程的质量\cite{kononenko2015investigating}。原则上，代码审核是一个透明的过程，代码审核应该对提交代码存在的缺陷具有预防性，审核人员的目标是及时评估提交代码的质量，然而，在实践中代码审核的执行过程会受到各种因素的影响\cite{baysal2016investigating}。 本文从代码审核数据中提取了10 种特征，用于描述代码修改及审核过程中非修改因素对代码修改完成时间的影响。}
\begin{table}[ht]
\begin{center}
\begin{footnotesize}
\caption{代码审核文本特征及描述}
\label{tf}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{类型}              & \textbf{特征}           & \textbf{符号} & \textbf{描述}             \\ \hline
\multirow{10}{*}{审核文本特征} & Owner                 & $MF_{0}$         & 修改提交的管理人员                \\ \cline{2-4}
                         & Author                & $MF_{1}$         & 修改提交的作者                 \\ \cline{2-4}
                         & Reviewers             & $MF_{2}$         & 修改提交的审核人员               \\ \cline{2-4}
                         & Project               & $MF_{3}$         & 修改所归属的项目                \\ \cline{2-4}
                         & Branch                & $MF_{4}$         & 修改所归属的项目分支              \\ \cline{2-4}
                         & Time                  & $MF_{5}$         & 修改提交的时间                 \\ \cline{2-4}
                         & Revierws\_Num         & $MF_{6}$         & 审核人员的数量                 \\ \cline{2-4}
                         & Author\_Sum           & $MF_{7}$         & 修改提交作者在项目中总的提交次数        \\ \cline{2-4}
                         & Author\_Sum\_M        & $MF_{8}$         & 修改提交作者在项目中近一个月的提交次数     \\ \cline{2-4}
                         & Reviewer\_Author\_Ave & $MF_{9}$         & 相同审核人员和作者的修改的平均审核次数 \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}
\par{本文提取的代码审核元特征如表\ref{tf}所示。$MF_{0}$表示该修改提交的管理人员，$MF_{1}$表示该修改提交的作者，$MF_{2}$ 表示修改提交的审核人员，我们用这三个特征来描述人力因素对完成周期的影响。通常同个软件项目下的开发人员和审核人员数量有限，不同的审核人员和开发人员对于软件项目熟悉程度的差异会导致软件修改工作所需要时间产生很大差距。同时，我们调研发现，审核人员对缺陷审查具有倾向性，有些审核人员容易忽略一些特定的代码缺陷；不同审核人员提供反馈意见的详细程度也存在差异，将直接影响开发人员的再次修改。$MF_{3}$表示该修改提交归属的项目，$MF_{4}$表示该修改提交所在的项目分支，我们用这两个特征衡量不同项目以及不同分支中代码修改工作的差异。不同项目以及分支中软件实体复杂程度不同，常见修改目标也不同，这些差异将体现在开发人员完成修改工作所需要的时间。另外，我们统计还发现，通常一项修改的审核工作存在多位审核人员，因此，我们收集了所有的审核人员信息，并增加了特征$MF_{6}$，用于标记参与该修改提交的审核人员数量。}
\par{Eyolfson等人\cite{eyolfson2011time}研究了修改的提交时间与提交代码的正确性之间的关系，他们发现在深夜到凌晨4点之间提交的代码更容易出错，同时，在早上7点到中午之间提交的代码错误更少。另外，该研究还发现开发人员提交代码的频率也影响着代码的正确率。参考该研究的结论，我们从代码审核数据中提取了代码提交时间$MF_{5}$以及开发人员在项目中的活跃度特征，活跃度特征通过开发人员在项目中总的提交次数$MF_{7}$和近一个月的提交次数$MF_{8}$ 来衡量。}
\par{我们直接从审核数据中提取的特征为文本特征，如人名，项目名等。在输入预测模型前，需要将文本特征转换成数值特征，常用的编码方法有直接编码和独热编码（one-hot）。以特征$MF_{2}$为例，存在600多个不同的审核人员，使用直接编码的方式，将转换成一维特征和600多种取值；使用独热编码的方式，对于$MF_{2}$特征下600多个可能取值，将产生600 多个二元特征，这些特征互斥且每次仅有一个特征激活，即每个样本仅有少数特征取值为1 （由于一个提交存在多为审核人员），其余特征取值都为0。 两种编码方式都存在明显缺陷，审核人员之间相互独立，而直接编码导致取值相差小的两位审核人员比取值相差大的更加具有相似性，并且直接编码使得不同样本之间的区分度变低；采用独热编码的方式虽然能让特征之间的距离更加合理，但是独热编码会导致特征向量过于稀疏，仅$MF_{2}$经编码后就产生600多个特征，不易于模型训练。针对这些问题，我们对直接编码和独热编码进行了结合和调整。如图\ref{fig:featurecode} 所示，首先，将文本类别特征按首字母划分为26 类，再对每个类下的文本进行直接编码，这种方式增加了样本差异性并且降低了向量维度。
\begin{figure}[h]
\centering
\includegraphics[width=5.5in]{myfigure/featurecode.pdf}
\caption{文本类别特征编码示例}
\label{fig:featurecode}
\end{figure}}
\subsubsection{代码结构耦合特征提取}
\par{软件系统经过多年的开发和维护，软件实体间存在复杂的关联关系。由于这些关联关系，代码修改会在软件实体间传播，从而增加了代码修改的工作的难度。代码修改传播机制\cite{hassan2004predicting} 表明，当两个类之间的结构耦合关系越复杂，则当其中一个类变更时，另一个类存在更大的可能被影响。因此，我们从修改代码中提取结构耦合特征，用于描述代码修改任务的复杂度。}
\par{在代码层次，入度和出度能直接反应一个软件实体的结构耦合特征，入度指当前实体调用修改提交中其他实体的次数；出度指当前实体被修改提交中其他实体调用的次数。修改所涉及的入度和出度能衡量该修改的复杂程度以及时间代价。本文从不同粒度提取软件实体的耦合特征共12维，如表\ref{cf}所示。下面我们按不同粒度分别介绍四种耦合规则，其中符号$C$、$M$、$A$分别表示类、方法、属性。}

\begin{table}[h]
\begin{center}
\begin{footnotesize}
\caption{代码结构耦合特征及描述}
\label{cf}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{类型}              & \textbf{特征}                          & \textbf{符号} & \textbf{描述}    \\ \hline
\multirow{12}{*}{代码耦合特征} & \multirow{4}{*}{Class to Class}      & $CF_{0}$          & 修改提交的类与类平均入度   \\ \cline{3-4}
                         &                                      & $CF_{1}$         & 修改提交的类与类入度总和   \\ \cline{3-4}
                         &                                      & $CF_{2}$          & 修改提交的类与类平均出度   \\ \cline{3-4}
                         &                                      & $CF_{3}$          & 修改提交的类与类出度总和   \\ \cline{2-4}
                         & \multirow{2}{*}{Method to Class}     & $CF_{4}$          & 修改提交的方法与类平均入度  \\ \cline{3-4}
                         &                                      & $CF_{5}$          & 修改提交的方法与类入度总和  \\ \cline{2-4}
                         & \multirow{2}{*}{Method to Attribute} & $CF_{6}$          & 修改提交的方法与属性平均入度 \\ \cline{3-4}
                         &                                      & $CF_{7}$          & 修改提交的方法与属性入度总和  \\ \cline{2-4}
                         & \multirow{4}{*}{Method to Method}    & $CF_{8}$          & 修改提交的方法与方法平均入度 \\ \cline{3-4}
                         &                                      & $CF_{9}$          & 修改提交的方法与方法入度总和 \\ \cline{3-4}
                         &                                      & $CF_{10}$         & 修改提交的方法与方法平均出度 \\ \cline{3-4}
                         &                                      & $CF_{11}$         & 修改提交的方法与方法出度总和  \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}
\par{\textbf{Class to Class: }根据面向对象编程语法，类层次的耦合关系最常见的有继承（Inheritance）和实现接口（Implementing Interface），$C_{i}$继承$C_{j}$或者实现$C_{j}$的接口，称$C_{j}$为$C_{i}$ 的入度；反之，则称$C_{j}$ 为$C_{i}$ 的出度。本文提取四个特征用于衡量修改提交在类与类层次的耦合特征：特征$CF_{0}$为当前修改提交中类的平均入度；特征$CF_{1}$为当前修改提交中类的入度总和；特征$CF_{2}$为当前修改提交中类的平均出度；特征$CF_{3}$为当前修改提交中类的出度总和。}
\par{\textbf{Method to Class: }在软件实体中，类包含了方法集合和属性集合。类与方法的耦合关系指的是类$C_{i}$的某个方法$M_{i}$中使用了另一个类$C_{j}$，且不是使用$C_{j}$中的方法或属性,这时类$C_{j}$为方法$M_{i}$的入度这种耦合关系常见的实例包括：强制类型转换（Type-Casting），异常抛出类型（Exception Throws），参数类型（Parameter Type），返回类型（Return Type）和类型验证（Instanceof）等。本文提取两个特征衡量修改提交在方法与类层次的耦合特征：特征$CF_{4}$为修改提交中所有方法（\emph{to Class}）的平均入度；特征$CF_{5}$为修改提交中所有方法（\emph{to Class}）的入度总和。}

\par{\textbf{Method to Attribute: }在面向对象编码示例中，方法与属性层次也经常存在耦合规则，它指的是位于类$C_{i}$中的某个方法$M_{i}$与类$C_{j}$中某个属性$A_{j}$之间的耦合关系，其中最常见的是静态属性调用（Static Attribute Invoking）。这种情况定义属性$A_{j}$为方法$M_{i}$的入度，我们提取两个特征用于描述方法与属性之间的耦合关系：特征$CF_{6}$表示修改提交中所有方法（\emph{to Attribute}）的平均入度；特征$CF_{7}$为修改提交中所有方法（\emph{to Attribute}）的入度总和。}
\par{\textbf{Method to Method: }方法与方法层次指的是位于不同类$C_{i}$、$C_{j}$的两个方法$M_{i}$和$M_{j}$之间建立的耦合关系，满足这种耦合关系的实例有静态方法调用（Static Method Invoking）,构造方法调用（Construction Method Invoking）等。这种耦合关系具有方法性，因此，我们通过四个特征来表达方法间的耦合特征：特征$CF_{8}$为当前修改提交中方法（\emph{to Method}）的平均入度；特征$CF_{9}$ 为当前修改提交中方法（\emph{to Method}）的入度总和；特征$CF_{10}$为当前修改提交中方法（\emph{to Method}）的平均出度；特征$CF_{11}$为当前修改提交中方法（\emph{to Method}）的出度总和。}
\subsubsection{代码修改特征}
\par{代码修改特征对于代码修改工作的时间代价具有很指向作用，我们从两个维度来提取修改提交中的代码修改特征，分别是代码修改量和代码修改内容。代码修改量能直接体现一项修改的工作量，而代码修改内容则是描述修改需要解决的问题和目标。代码修改量与修改内容都直接影响着代码修改阶段以及代码审核阶段所需的时间。}
\par{具体地，在代码修改量维度，可以细粒度的划分为涉及修改类的数量、修改方法的数量、修改语句的数量；而从代码变更的类型，还可以划分为增加（\emph{add}）、修改（\emph{change}）和删除（\emph{delete}）。如表\ref{mf}所示，本文提取了18维特征用于描述代码修改任务中修改量。}
\par{特征$MF_{0}\sim MF_{2}$表示涉及变更的代码语句数量，包括新增代码语句的数量、修改代码语句的数量和删除代码语句的数量。特征$MF_{3}\sim MF_{6}$描述涉及修改的类的数量，分别代表新增类的数量、修改类的数量、删除类的数量以及类名修改的数量。其中类名的修改会引入一系列类引用上的修改问题。在方法层次，特征$MF_{7}\sim MF_{10}$分别代表方法新增的数量，方法删除的数量，方法名变更数量以及方法返回类型修改的数量。特征$MF_{11}\sim MF_{14}$代表涉及变更的参数数量，包括参数类型修改，参数名修改以及参数增加和删除。特征$MF_{15}\sim MF_{16}$分别表示属性类型与属性名的修改。另外，我们还发现提交表达式的修改是代码修改工作中频率较高的修改类型，并且条件语句的修改会对代码流程产生较大影响，因此我们用特征$MF_{17}$表示涉及修改的条件表达式的数量。}

\begin{table}[h]
\begin{center}
\begin{footnotesize}
\caption{代码修改量特征及描述}
\label{mf}
\begin{tabular}{|c|c|c|}
\hline
\textbf{类型}               & \textbf{符号} & \textbf{描述} \\ \hline
\multirow{18}{*}{代码修改量特征} & $MF_{0}$         & 新增代码行数      \\ \cline{2-3}
                          & $MF_{1}$         & 修改代码行数      \\ \cline{2-3}
                          & $MF_{2}$        & 删除代码行数      \\ \cline{2-3}
                          & $MF_{3}$         & 新增类的数量      \\ \cline{2-3}
                          & $MF_{4}$         & 修改类的数量      \\ \cline{2-3}
                          & $MF_{5}$         & 删除类的数量      \\ \cline{2-3}
                          & $MF_{6}$         & 重命名类的数量     \\ \cline{2-3}
                          & $MF_{7}$         & 新增方法的数量     \\ \cline{2-3}
                          & $MF_{8}$         & 删除方法的数量     \\ \cline{2-3}
                          & $MF_{9}$         & 重命名方法数量     \\ \cline{2-3}
                          & $MF_{10}$        & 变更返回类型的方法数量 \\ \cline{2-3}
                          & $MF_{11}$        & 参数类型变更的数量   \\ \cline{2-3}
                          & $MF_{12}$        & 参数名变更数量     \\ \cline{2-3}
                          & $MF_{13}$        & 新增参数数量      \\ \cline{2-3}
                          & $MF_{14}$        & 删除参数数量      \\ \cline{2-3}
                          & $MF_{15}$        & 属性名变更数量     \\ \cline{2-3}
                          & $MF_{16}$        & 属性类型变更数量    \\ \cline{2-3}
                          & $MF_{17}$        & 条件表达式变更数量   \\ \hline
\end{tabular}
\end{footnotesize}
\end{center}
\end{table}

\par{在修改内容维度，我们采用与本文2.2节中相同的方法。我们对所有修改提交中涉及修改的代码片段进行文本预处理，再以预处理后的文本构建语料库。最后，通过Word2vec方法训练词向量模型，以50维的特征向量表示修改提交中的修改内容。}
\subsection{机器学习算法选择及模型评估方法}
\par{本文提出的代码修改周期预测方法基于有监督机器学习算法，具体地，我们通过代码修改的审核次数评估代码修改的周期长短。我们将代码修改周期预测视为分类问题，在实验预测中，审核次数被划分为三个区间，分别对应代码修改周期的较短、一般以及较长三个层次。我们从开源项目的历史修改提交数据中提取审核元特征，代码耦合特征以及代码修改特征，再基于这些特征训练机器学习模型。最后使用训练好的模型对新的修改任务预测修改周期。}
\subsubsection{机器学习算法选择}
\par{在本文中，采用有监督机器学习算法，其中，常见的分类算法有逻辑回归（\emph{LR}，Logistic Regression），支持向量机（\emph{SVM}，Support Vector Machines），随机森林（\emph{RF}，Random Forest），人工神经网络（\emph{ANN}，Artificial Neural Networks）以及\emph{XGBoost}（Extreme Gradient Booting）。在实验中，我们通过对比各种分类算法在两个开源项目中的分类效果，选择表现最优的\emph{XGBoost} 作为我们的分类模型。}
\par{\emph{XGBoost} 是梯度提升树模型（Gradient Boosting Trees）的一种高效实现方式。\emph{XGBoost} 集成了K颗\emph{CART}树（Classification and Regression Trees）\{$Tr_{1}(x_{1},y_{1})$, $Tr_{2}(x_{2},y_{2})$..., $Tr_{k}(x_{k},y_{k})$\}。其中，$x_{i}$ 表示第 $i^{th}$ 个样本的特征，$y_{i}$ 则表示该样本对应的标签。\emph{CART} 树将分配给每个叶子节点一个分数，而最终的预测结果将由所有\emph{CART} 树上对应叶子节点的分数通过加法模型得到，如公式所示\ref{xgb1}}。
\begin{equation}
    \hat{y}=\sum_{k=1}^{K}f_{k}(x_{i}),\quad\quad f_{k}\in F \label{xgb1}
\end{equation}
\par{在上述公式中，$f_{k}(x_{i})$ 为第 $k^{th}$ 颗树的预测分数，$F$ 则代表函数空间中所包含的所有树模型。相比于传统的梯度提升树模型，\emph{XGBoost} 一个重要的改进是在目标函数中加入了正则项。公式\ref{xgb2}为\emph{XGBoost}的目标函数。}
\begin{equation}
Obj(\Theta )=\sum_{i=1}^{n}l(y_{i},\hat{y_{i}})+\sum_{k}^{K}\Omega (f_{k}) \label{xgb2}
\end{equation}
\par{其中，$l$ 为损失函数，描述的是预测标签 $\hat{y_{i}}$ 与真实标签 $y_{i}$ 之间的误差。而在表达式 $\sum_{k}^{K}\Omega (f_{k})$ 中，$\Omega (f)=\gamma T+\frac{1}{2}\lambda \sum_{j=1}^{T}\omega _{j}^{2}$ 用于描述模型的复杂度。$T$ 和 $\omega$ 分别表示叶子数量及对应叶子节点上的取值。$\gamma$ 和 $\lambda$ 则用于控制正则化的惩罚程度。}
\subsubsection{模型评估方法}
\par{为了评估修改周期预测模型的有效性，我们采用了分类模型评价中常用的四个指标：召回率、精确率、准确率以及$F_{1}$值。召回率用于度量模型对特定类别样本的预测安全性，如对一些修改周期较长的样本，是否能准确预测；精确率用于度量分类模型的预测结果的精确性；而准确率及$F_{1}$则考察模型对多个类别预测的综合效果。四个指标的定义如下：
}
\begin{equation}
    precision=\frac{TP}{TP+FP}
\end{equation}
\begin{equation}
    recall=\frac{TP}{TP+FN}
\end{equation}
\begin{equation}
    F_{1}= 2\ast \frac{precision\ast recall}{precision+recall}
\end{equation}
\begin{equation}
    accuracy=  \frac{TP+FN}{TP+FN+TN+FP}
\end{equation}
\par{以二分类为例（多分类视为多个二分类问题），$TP$ 和$TN$ 分别表示正确预测的正样本数量和负样本数量，$FP$ 和$FN$分别表示错误预测的正样本数量和负样本数量。}
\subsection{代码修改周期预测实验设置与评估}
\par{本节首先描述了实验数据的收集及去噪处理方法，然后介绍了在修改周期预测实验中关注的三个研究问题，最后分析了模型预测的实验结果。}
\subsubsection{数据收集及去噪处理}
\par{我们从Gerrit代码审核工具中收集开源项目的历史提交信息以及代码审核信息。我们选择了Ecplise\footnote{https://www.eclipse.org/}和OpenDaylight\footnote{https://www.opendaylight.org/}两个项目作为实验数据集。其中，Ecplise是使用最广泛的集成开发环境之一，而OpenDaylight是一种高度可用、模块化以及可扩展的多协议控制器基础架构，用于供应商网络上的SDN部署。Ecplise和OpenDaylight都拥有丰富的代码修改历史数据，可用于代码修改周期的分析。表格展示了实验数据集的详细信息。}
\begin{table}[h]
\caption{代码修改周期预测实验数据集}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Projects} & \textbf{Time span} & \textbf{No. of reviews} \\ \hline
Eclipse           & 2016.1-2018.5      & 9455                    \\ \hline
OpenDaylight      & 2017.1-2018.8      & 6403                    \\ \hline
\end{tabular}
\label{tab4}
\end{center}
\end{table}
\par{另外，我们对大量代码修改数据进行观察，发现其中存在一些噪声数据，这些数据对模型的训练产生负面影响。我们设置了一下几条规则对噪声数据进行过滤：
\begin{itemize}
    \item[1)]在代码修改周期的预测中，我们需要从被修改的代码中提取代码修改特征及代码耦合特征。许多提交中不涉及代码修改，我们将过滤这部分的提交数据。
    \item[2)]我们同时去除数据集中，明显存在异常的修改提交。例如，有一个修改提交需要经过150次的反复修改和审核，而所有修改数据的平均修改和审核次数为5次。
    \item[3)]另外，我们还去除了项目中不活跃的开发人员的修改提交。我们认为修改提交次数低于两次的开发人员为项目中的非核心维护人员，这些开发人员只在项目中完成极少数的代码修改工作。
\end{itemize}
}
\subsubsection{代码修改周期预测的问题研究}
\par{文章的主要目的是从代码修改及代码审核两个阶段分析代码修改周期，试着通过代码修改及审核次数预测代码修改周期的长短。本节从多个角度研究，评估本文提出的代码修改周期预测方法的有效性。我们关注的研究问题有以下三个：}
\par{\textbf{研究问题1：本文方法对代码修改任务能否在较短周期内完成的预测效果如何？}}
\par{开发人员都希望代码修改任务能在较短的时间周期内完成，即一次修改和审核周内，其中关键的是代码修改不存在问题并且在代码审核过程被接受。值得注意的是，在这个研究问题中，我们将审核次数为1的提交数据视为正样本，其余提交数据视为负样本。因此，我们使用本文提出的方法，训练预测模型，预测代码修改任务的审核次数是否为1。数据集中正负样本分布如表\ref{distibution1}所示。}
\begin{table}[h]
\caption{研究问题1的样本分布}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{Projects} & \textbf{Positive} & \textbf{Negative} \\ \hline
Eclipse           & 2905              & 6551              \\ \hline
OpenDaylight      & 1598              & 4807              \\ \hline
\end{tabular}
\label{distibution1}
\end{center}
\end{table}
\par{\textbf{研究问题2：本文方法对代码修改周期的长短的预测效果如何？}}
\par{观察图***可以发现，一项代码修改任务所花费时间周期的长短可以根据代码修改和审核次数来划分。在这个研究问题中，我们通过划分审核次数区间，来对应代码修改周期长短的层次。审核次数为1的提交的平均修改周期为1天，我们将这类修改对应为“较短”的代码修改周期；审核次数在2-6区间的提交的平均修改周期为1周内，我们认为这类修改任务对应代码修改周期长短为“一般”；而审核次数在7-20区间的提交的平均修改周期大于一周，我们则认为这类修改任务需要“较长”的修改周期。经过划分后的数据分布如表所示} 
\begin{table}[ht]
\caption{研究问题2的样本分布}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Projects} & \textbf{1 Reviews} & \textbf{2-6 Reviews} & \textbf{7-20 Reviews} \\ \hline
Eclipse           & 2905               & 5203                 & 1287                  \\ \hline
OpenDaylight      & 1598              & 3327                 & 1338                  \\ \hline
\end{tabular}
\label{distibution2}
\end{center}
\end{table}
\par{\textbf{研究问题3：三种类型的特征对模型预测效果的影响如何？}}
\par{本文方法的核心是从代码修改的历史信息中提取审核元特征、代码耦合特征及代码修改特征，用于度量代码修改的时间周期长短。三种特征代表了代码修改阶段及代码审核阶段对代码修改周期的影响。在这个研究问题中，我们关注于三种类型各自的特征对模型预测效果的影响。}
\subsubsection{实验结果与分析}
\par{\textbf{研究问题1：本文方法对代码修改任务能否在较短周期内完成的预测效果如何？}}
\begin{table}[ht]
\caption{研究问题1实验结果}
\begin{center}
\begin{scriptsize}
\begin{tabular}{|c|c|ccccccc|}
\hline
                               &                                 & \multicolumn{3}{c|}{Positive Instances}                                                        & \multicolumn{3}{c|}{Negative Instances}                                                        &                               \\ \cline{3-8}
\multirow{-2}{*}{Projects}      & \multirow{-2}{*}{Method}        & \multicolumn{1}{c|}{$precision$} & \multicolumn{1}{c|}{$recall$}   & \multicolumn{1}{c|}{$F_{1}$}       & \multicolumn{1}{c|}{$precision$} & \multicolumn{1}{c|}{$recall$}   & \multicolumn{1}{c|}{$F_{1}$}       & \multirow{-2}{*}{$Accuracy$}    \\ \hline
                               & LR                              & 69.39                          & 33.72                         & 45.38                         & 74.84                          & 92.98                         & 82.93                         & 73.99                         \\
                               & SVM                             & 69.89                          & 42.98                         & 53.22                         & 77.24                          & 91.27                         & 83.67                         & 75.79                         \\
                               & RF                              & 76.85                          & 40.00                         & 52.55                         & 76.85                          & 94.23                         & 84.69                         & 76.85                         \\
                               & ANN                             & 63.21                          & 49.42                         & 55.47                         & 78.37                          & 86.44                         & 82.21                         & 74.58                         \\
\multirow{-5}{*}{Eclipse}      & \cellcolor[HTML]{E1DDDD}XGBoost & \cellcolor[HTML]{E1DDDD}71.63  & \cellcolor[HTML]{E1DDDD}54.80 & \cellcolor[HTML]{E1DDDD}62.10 & \cellcolor[HTML]{E1DDDD}82.16  & \cellcolor[HTML]{E1DDDD}90.56 & \cellcolor[HTML]{E1DDDD}86.16 & \cellcolor[HTML]{E1DDDD}79.72 \\ \hline
                               & LR                              & 60.47                          & 33.66                         & 43.24                         & 78.36                          & 78.36                         & 84.66                         & 74.86                         \\
                               & SVM                             & 41.38                          & 19.41                         & 26.43                         & 77.52                          & 90.10                         & 83.72                         & 73.34                         \\
                               & RF                              & 51.75                          & 43.04                         & 46.99                         & 82.32                          & 86.86                         & 84.53                         & 76.06                         \\
                               & ANN                             & 49.18                          & 9.71                          & 16.22                         & 76.59                          & 96.71                         & 85.49                         & 75.26                         \\
\multirow{-5}{*}{OpenDaylight} & \cellcolor[HTML]{E1DDDD}XGBoost & \cellcolor[HTML]{E1DDDD}50.39 & \cellcolor[HTML]{E1DDDD}50.78 & \cellcolor[HTML]{E1DDDD}50.58 & \cellcolor[HTML]{E1DDDD}87.57  & \cellcolor[HTML]{E1DDDD}87.40 & \cellcolor[HTML]{E1DDDD}87.49 & \cellcolor[HTML]{E1DDDD}80.03 \\ \hline
\end{tabular}
\label{RQ1 result}
\end{scriptsize}
\end{center}
\end{table}
\par{表格\ref{RQ1 result}展示了本文方法对代码修改任务能否在较短周期内完成的预测效果，包括正负样本的召回率、精确率和 $F_{1}$值，以及综合预测效果的准确率。在实验中，我们测试对比了本文提出方法在多个机器学习模型上的效果，并采用10折交叉验证方法。针对数据集样本分布不平衡问题，使用SMOTE算法生成训练集中占比较低的样本，测试集中不做改变。} 
\par{观察表\ref{RQ1 result}可以发现，在两个数据集上不同机器学习模型的预测准确率分布为73.34\%至80.03\%，这体现了本文提出方法对代码修改任务能否在较短周期内完成的预测的准确性。对比不同机器学习模型的效果，可以发现\emph{XGBoost}取得了最优的表现。在Eclipse数据集上，\emph{XGBoost}对负样本预测的召回率、精确率和 $F_{1}$值分别是82.16\%，90.56\%和86.16\%，意味着大部分负样本都能被准确预测。负样本代表可能需要重复多次修改的提交，对该类样本的预测有助于开发人员和项目管理提前做出调整和安排。另一方面，在正样本的预测效果上，多种机器学习模型的效果都要低于在负样本上表现。我们认为原因是SMOTE算法并不能完全解决样本不平衡的问题。}
\par{另外，我们可以发现\emph{XGBoost} 的负样本召回率要稍微低于其他机器学习模型，与之类似的是，}
